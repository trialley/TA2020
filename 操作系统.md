网络中的数据是如何流向的（参考《构建高性能web站点》），iptables的三表五链、Nginx的网络IO模型(这个很重要，你要能讲清楚为什么Nginx要比Apache好)，马哥Linux对于这个部分的内容讲解是我最喜欢的，我强力推荐大家都去听一听马哥的视频。

7. 


9. 阿里巴巴对应届生的知识面、知识的理解程度要求还是比较高的，在我的整个C++面试过程中，问的最多的就是IO复用、智能指针、内存泄漏的问题如何解决、如何排查Load高的问题、Linux内核相关的知识等

10. 

11. 进程与线程的区别
       多进程与多线程区别，应用场景
       volatile和原子变量的区别
       proc文件系统
       自旋锁与普通锁的区别

       虚拟内存
       进程的内存分布
       栈内存为什么由系统自动分配和释放
       守护进程如何创建
       进程间的通信方式及其区别，应用场景
       死锁条件和解除
       进程调度方式
       对编译连接的理解
       共享内存实现原理
       僵尸进程是什么，如何处理
       自旋锁在单cpu与多cpu下的使用
       用户态与内核态

12. ★★★ 进程与线程的本质区别、以及各自的使用场景。

13. ★☆☆ 进程状态。

14. ★★★ 进程调度算法的特点以及使用场景。

15. ★☆☆ 线程实现的方式。

16. ★★☆ 协程的作用。

17. ★★☆ 常见进程同步问题。

18. ★★★ 进程通信方法的特点以及使用场景。

19. ★★★ 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁。

20. ★★★ 虚拟内存的作用，分页系统实现虚拟内存原理。

21. ★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。

22. ★★★ 比较分页与分段的区别。

23. ★★★ 分析静态链接的不足，以及动态链接的特点。

24. ★★☆ 文件系统的原理，特别是 inode 和 block。数据恢复原理。

25. ★★★ 硬链接与软链接的区别。

26. ★★☆ 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。

27. ★★★ 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。

28. 6、进程与线程的区别

29. 操作系统为什么有用户态和内核态，用户级线程与内核级线程如何转换

30. 6、expoll了解吗

31. 看你使用过gevent 那么说一说，什么是协程，协程的切换是怎么做到的 ？

32. 协程的调用栈切换

33. 1.操作系统的调度算法了解么 说一说

    2.惊群知道么？

    比如进程间通信，尽可能回答那些进程间通信方式的底层实现；

    线程同步方式可以讲一讲，操作系统底层是如何实现锁的，那些同步方式的底层又是如何实现的；








百世经纶·一页书

# 面试资料-Linux

1398 浏览3 回复2019-11-20

[![img](https://uploadfiles.nowcoder.com/images/20190815/1679611_1565845039598_DF9BB3AE2998E35CF56AA29E8F5B918F)](https://blog.nowcoder.net/profile/1679611)

[百世经纶·一页书](https://blog.nowcoder.net/profile/1679611)

[+关注](javascript:void(0);)

# Linux 相关面试知识与问题

## 概念

- 

## 进程

一个进程关联的用户有很多:

- **实际用户id, 实际组id**: 是谁在执行本进程, 一般是执行程序的用户, 在登录会话期间不变, root进程可以改变此值.
- **有效用户id, 有效组id**: 用于文件访问权限检查, 一般就是实际用户/组ID, 但是如果可执行文件设置了set-user-ID位和set-group-ID位,
  则执行此文件时, 将文件的所有者/所在组设置为有效用户/组ID. 该权限位在chmod命令中用 s 表示(一般替代x).
- **保存的设置用户id, 保存的设置用户id**: 由exec函数保存.

Linux下进程有5种状态:

- task_running: 进程已就绪或正在执行.
- task_interruptible: 进程被阻塞, 处于休眠状态, 当等待的条件满足时可以转变为 task_running.
  当收到信号时也可以被唤醒而运行.
- task_uninterruptible: 进程被阻塞, 处于休眠状态, 当等待的条件满足时可以转变为 task_running.
  但是不能被信号唤醒. 例如在终端中kill某些进程时无法结束进程, 这些进程就处于此状态.
  kill 默认发送的是 TERM 信号, 可以被屏蔽. 可以改为发送 KILL 信号, 此信号无法进程被捕获, 动作是直接结束进程.
- task_traced: 进程被其他进程跟踪.
- task_stopped: 进程停止执行. 当进程收到 SIGSTOP, SIGSTP, SIGTTIN, SIGTTOU 等信号时会转变为此状态.

### 进程调度(CFS, completely fair scheduler)

CFS调度策略不是将nice值映射为固定的时间片长度, 而是将其作为分配时间片的权值,
即nice值大的进程分配的时间片比nice值小的进程获得的时间片短.

linux 对**实时进程**和**普通进程**采用不同的调度策略.

对于实时进程, linux 分为两种: *先进先出的实时进程(SCHED_FIFO)\*和*时间片轮转的实时进程(SCHED_RR)*.
对于前者, linux 采用抢占式的优先级调度算法, 进程可以一直占用cpu直到被更高优先级的进程抢占或进程终止/阻塞.
对于后者, linux 同样支持高优先级进程抢占, 并且进程阻塞/终止/时间片用尽时也会放弃cpu.
实时进程的优先级为0-99.

每个普通进程都有自己的**静态优先级**(100到139, 100表示最高优先级, 139表示最小)和**动态优先级**(100-139, 100最高, 139最小).
子进程会继承父进程的静态优先级, 也可以通过 nice() 和 setpriority() 来改变自己拥有的进程的静态优先级.
100到139分别对应了nice值的-20到19.

静态优先级决定了进程的**基本时间片**, 值越小, 静态优先级越高, 时间片越长.
基本时间片是进程用完了之前的时间片时, 系统分配给进程的时间片长度.
动态优先级是调度程序在选择新的进程来运行时使用的, 是通过静态优先级和 bonus([0, 10]) 计算得到,
bonus 与进程的**平均睡眠时间**正相关, 这避免了进程饿死.

动态优先级 = max(100, min(静态优先级 - bonus + 5, 139))动态优先级=*m**a**x*(100,*m**i**n*(静态优先级−*b**o**n**u**s*+5,139))

为了防止进程饿死, linux将进程分为**活动进程**和**过期进程**.
**活动进程**指那些还没有用完自己时间片的进程, **过期进程**指已经用完了时间片, 但是还可以继续运行(即没有阻塞, 处于就绪状态)的进程.
活动进程被允许运行, 而过期进程要等活动进程运行完之后才可以运行.
但是为了保证**交互式进程**能及时被响应, 即使已经用完了时间片, 调度程序也会将其作为活动进程.

每个CPU都有一个数据结构(rq, kernel/sched/sched.h), 记录了自己的运行队列. 其中有多个不同的**调度类**成员, 保存着对应的进程.

linux中定义了多种**调度类**(scheduler class), 不同的调度类执行不同的调度算法.
例如 cfs 就是一种调度类, 采用的是 cfs 调度算法, 一般普通进程使用此调度类.
还有 rt 调度类(real time, 实时), 实时进程采用此调度类, 还有 dl 调度类(dead line).
调度类内部一般用红黑树组织进程, 将进程优先级作为键值, 保证了log(n)的复杂度.
调度类实现了标准接口, 可以从其中选出最先运行的进程, 或者加入/删除进程.

shedule() 实现了调度程序, 在其任务是从运行队列的链表中找到一个进程, 并将CPU分配给该进程, 使之开始运行.
shedule() 由几个内核控制路径调用, 可以采取**直接调用**或**延迟调用**的方式.

**直接调用**: 如果当前的进程阻塞(如等待IO), 调度程序会被调用. 过程如下:

1. 将当前进程插入到对应的等待队列.
2. 将当前进程的状态设为 task_interruptible 或 task_uninterruptible.
3. 调用shedule().
4. 检查资源是否可用, 如果不可用就转到第2步, 如果可用就将进程从等待队列中移除.

**延迟调用**: 可以将当前进程的 TIF_NEED_RESCHED 标志设为1, schedule() 会在随后的某个时刻被明确调用.
这是因为内核返回用户态前(即从系统调用中退出)会检查此标志, 如果标志被设置, 就会调用 schedule() 函数.
例如:

- 当前进程用完CPU时间片时, 内核会设置该标志, 随后 schedule() 被调用.
- 当一个被唤醒的进程的优先级比当前进程优先级高时.
- 当调用系统调用 sched_setshceduler() 时.

那么, schedule() 函数如何要运行的进程呢. schedule() 选择优先级最高的调度类(rt > cfs),
从中选出优先级最高(注意说的这不是前面的动态优先级, 动态优先级越高, 这里的优先级越低)的使之运行.

### 进程间的关系

**进程组(process group)**是一个或多个进程的集合. 每个进程都有一个进程组id(pgid)表明自己属于哪个进程组.

- 每个进程组有一个组长进程, 组长进程的pid等于进程组的pgid.
- 进程组一直存在, 直到进程组中的进程都终止/离开, 而与组长进程是否终止没有关系. 进程组从出现到最后一个进程终止/离开的时间称为其生命期.
- 子进程默认父进程的进程组id, 每个进程都可以设置自己和子进程的进程组. 当子进程执行了 exec 之后父进程就不能设置其pgid.
- 进程可以指定新的进程组id为自己的pid, 从而创建新的进程组, 并使自己成为进程组组长.
- 通常用管道将几个进程编为一组, 例如在shell中用管道把几个命令连接起来. 通常shell会为每个命令创建一个独立的进程,
  并他们组织为一个进程组, 第一个命令对应的进程是进程组组长. 也将此进程组称为一个**作业(task)**.

------

**会话(session)**是一个或多个进程组的集合, 每个会话由一个**会话首进程(session leader)**创建,
通常也将*会话首进程*的pid作为会话的**会话id**, *会话首进程*是该进程所属进程组的进程组长.

可以调用 setsid() 来新建一个会话, 这也会导致新的进程组的建立. 要求当前进程不是进程组组长, 步骤如下:

1. 建立新的会话, 进程成为新会话的*会话首进程*. 此时, 会话中只有一个进程.
2. 建立新的进程组, 进程成为新的进程组组长, 新进程组id是当前进程的pid.
3. 进程没有控制终端. 如果在调用 setsid 之前该进程有一个控制终端, 联系也会被切断.

由于 setsid 要求进程不能是进程组组长, 因此一般先调用 fork, 父进程结束, 在子进程中调用 setsid, 就能保证这个要求.

------

在一个终端创建进程时, 可以将部分进程组设置为后台执行(在命令后面加 &), 将后台执行的进程组称为**后台进程组**,
在前台执行的称为**前台进程组**. 二者都属于同一会话, *会话首进程*一般是shell进程.

区分前台/后台进程组的原因是: 前台/后台进程组都可以向控制终端写, 但是控制终端的输入和信号只会发送给前台进程组的所有进程.
例如在键盘按下 ctrl+c 的时候, 终端产生一个 SIGINT 信号, 发送给前台进程组的所有进程.
唯一的例外是在远程登录/退出终端时, 如果终端接口检测到网络已断开连接, 就将挂断信号发送给*会话首进程*(控制进程).

- ctrl + c: SIGINT, 中断进程
- ctrl + : SIGQUIT, 退出
- ctrl + z: SIGTSTP, 挂起进程.

------

**守护进程(daemon)**是一种生存期很长的进程, 通常在系统引导装入时启动, 系统关机时终止, 没有控制终端.
使一个进程成为守护进程的步骤为:

1. 调用mask修改文件模式创建屏蔽字, 例如设为0.
2. 调用fork, 再结束父进程, 在子进程中继续进行操作. 这是为了防止当前进程是进程组的组长.
3. 调用setsid创建一个新的会话. 这会使得当前进程成为会话首进程, 并成为新的进程组的组长进程, 并切断与控制终端的联系.
4. 调用chdir/fchdir系统调用, 更改进程的当前工作目录, 例如可以更改为根目录. 这是因为进程初始的工作目录可能需要被卸载,
   如果不改变工作目录, 会导致其无法被卸载.
5. 关闭不再需要的文件描述符. 可以通过 getrlimit 函数来获取合法的最大文件描述符号(尽管进程可能没有使用到),
   再遍历所有合法的文件描述符, 一一关闭他们.
6. 将标准输入/输出, 错误输出(即0, 1, 2文件描述符)绑定到某些文件, 例如/dev/null. 这样, 当进程中有标准输入输出时不会有任何效果.

通常linux系统会实现一个集中的守护进程出错记录设施, 守护进程的错误输入可以通过提供的接口输出.

**单实例守护进程**可以通过文件锁实现, 即同一守护进程对同一文件加锁, 失败则退出, 就可以保证只会有一个同样的守护进程.

### 进程间通信

下面这些通信方式的实现大都是这样：由内核维护一个数据结构，对数据结构的访问是经过同步的（原子操作或某种锁，如自旋锁等），
当无法获取资源，需要需要等待时，就将进程加入到数据结构包含的等待队列中。一旦资源就绪，内核就将进程转移为就绪状态。

- 匿名管道

  一般是半双工, 使用 int pipe(int fd[]) 函数创建, fd[0]用于读, fd[1]用于写.
  fork子进程后, 在父子进程中分别关闭读/写文件描述符, 之后就可以开始写/读, 以实现父子进程的通信.
  多个进程可以同时写管道, 只要写的数据量不超过PIPE_BUF, 写操作就是原子的, 不会发生交叉.

  FILE* popen(const char *cmd, const char *type) 函数会创建子进程执行 cmd 命令,
  并在父子进程之间建立一个管道, type 指明是父进程是读还是写, 对应子进程是写/读管道,
  对应的管道会被绑定到进程的标准输出/输入.

  有引用计数, 当关联进程全部退出, 管道就会被删除.

- 命名管道(FIFO)

  命名管道基于FIFO类型的文件, 可以在两个无关进程中使用.

  首先通过 int mkfifo(const char *path, mode_t mode) 创建FIFO文件, 再在进程中用 open 函数打开文件,
  就可以实现进程间的通信.

  多个进程可以同时写管道, 只要写的数据量不超过PIPE_BUF, 写操作就是原子的, 不会发生交叉.

  有引用计数, 当关联进程全部退出, 管道就会被删除.

- XSI IPC

  在内核中维护一个IPC结构, 用一个非负整数标识符标识, 每个IPC结构都关联一个键(key),
  进程通过键来使用IPC结构.

  进程可以通过指定 key = IPC_PRIVATE 来新建一个IPC结构,
  也可以通过 key_t ftok(const char *path, int id) 函数来获得一个 key, 然后通过其他函数创建key指定的IPC结构.

  XSI IPC 没有引用计数, 因此当向一个消息队列发送数据之后, 消息队列和数据会一直留在系统中, 直到:
  某个进程接收消息或删除队列; 系统重启时删除队列.

- XSI消息队列

  int msgget(key_t key, int flag) 可以获取一个消息队列, 返回一个 msqid,
  之后可以通过msgsnd, msgrcv函数来向此队列发送/接受数据.

  int msgsnd(int msqid, const void *ptr, size_t nbytes, int flag)函数用于向队列发送消息.
  ssize_t msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag)用于从队列中取出消息.

  不一定是先进先出, 可以通过type参数获取指定类型的消息.

- XSI信号量

  实际上是一个计数器, 用于为多个进程提供对共享数据对象的访问.

  在进行信号量操作申请资源时, 如果指定了SEM_UNDO, 那么内核会记住调用进程申请了多少资源.
  进程终止时, 内核会检验进程是否有尚未处理的信号量调整值, 如果有, 就会释放该资源.

  获取信号量的步骤，信号量包含一个表示资源数的值：

  1. 将值减去请求数，再检查值是否小于0。这个步骤是原子的。

  2. 如果值小于0，就将进程阻塞，加入到信号量对应的等待队列中（需要对队列加锁）。
     如果值大于等于0，表明进程获得了信号量，可以继续运行。

     释放信号量的步骤：

  3. 将值加上占用的资源数，再检查值是否小于0。这个步骤是原子的。

  4. 如果值小于0，表明还有进程在等待资源，就唤醒一个睡眠的进程。（那么如果可以唤醒多个进程呢？）
     如果值大于等于0，什么事也不做。

- XSI共享内存

  要注意在多个进程间同步对共享内存的访问.

  共享内存和mmap的区别是前者不要求存在实际的文件.

  int shmget(key_t kry, size_t size, inmt flag) 用于获取共享存储的ID, 返回共享存储的标识符.

  void* shmat(int shmid, const void* addr, int flag) 用于将共享存储连接到进程的地址空间,
  返回值是共享存储在进程地址空间的首地址.

  int shmdt(const void *addr) 用于将共享存储与进程分离. 此时该IPC结构及其标识符仍然存在,
  直到某个进程显式删除之(用shmctl函数).

  shmget基于VFS, 会创建一个文件对象, 然后进程可以利用mmap将其映射到自己的内存空间.

- POSIX信号量

  相比XSI信号量更加高效

- 信号

  用于通知进程某个事件已经发生.

- 套接字

## 线程

从 linux2.6 开始, glibc采用了新的线程库, NPTL(Native POSIX Threading Library).
内核仍然用 task_struct 结构保存线程信息, 并增加 tgid(thread group ID) 字段(也有pid字段).
创建新线程时, 仍然为其分配pid. 但是如果是主线程, 其 tgid 设为 pid. 如果不是主线程, 就将 tgid 设为所在进程在 pid.
因此获取进程信息时, 只要检查其 tgid 和 pid 是否相等, 就可以判断线程是否是主线程, 并获取其所在线程组的主线程.
参考[linux线程实现机制（上）](https://blog.csdn.net/HandsomeHong/article/details/73928873).

**线程的状态**分为两种:

- detached 状态: 线程被分离, 线程结束时其底层资源立即被回收, 也不能用pthread_join来等待其终止状态.
- joinable 状态: 线程的终止状态会保存, 直到对该线程调用pthread_join.

### 线程间同步

- 互斥锁

  `pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;` `int` `pthread_mutex_init(pthread_mutex_t *restrict mutex,``          ``const` `pthread_mutexattr_t *restrict attr);` `int` `pthread_mutex_destroy(pthread_mutex_t *mutex);` `int` `pthread_mutex_lock(pthread_mutex_t *mutex);` `int` `pthread_mutex_trylock(pthread_mutex_t *mutex);` `int` `pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,``              ``const` `struct timespec *restrict abstime); ``// abstime是绝对时间.` `int` `pthread_mutex_unlock(pthread_mutex_t *mutex);`

- 读写锁

  必须先对读写锁进行初始化, 最后必须用destory函数清理初始化时获得的资源.

  `pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;` `int` `pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,``            ``const` `pthread_rwlockattr_t *restrict attr);` `int` `pthread_rwlock_destroy(pthread_rwlock_t *rwlock);` `int` `pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);` `int` `pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);` `int` `pthread_rwlock_unlock(pthread_rwlock_t *rwlock);` `int` `pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);` `int` `pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);` `int` `pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock,``              ``const` `struct timespec *restrict abstime);` `int` `pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock,``              ``const` `struct timespec *restrict abstime); ``// abstime是绝对时间.`

- 自旋锁

  自旋锁是忙等, 未获得锁时不会陷入阻塞, 而是一直检测锁, 因此会一直占用CPU, 也因此效率更高.
  但是当线程因为时间片用完等原因被取消调度时, 线程进入休眠, 也就无法运行自旋锁,
  因此线程阻塞在自旋锁的时间可能会比预期长.

  自旋锁包含一个字段指示当前状态，为1时表示空闲，其他值表示已被占用，初始时为1。实现方式如下：
  获取自旋锁时：

  1. 将该字段与一个寄存器的值(值为0)交换, 该操作是原子的.

  2. 检查寄存器的值. 如果为0, 表明锁已经被占用. 则等待锁被释放.(此时还会更新一些其他字段.)
     如果为1, 表明锁是空闲的, 进程立即获得锁.

     释放自旋锁：

  3. 将该字段与一个寄存器的值（值为1）交换。

     `// pshared 取值可以是 PTHREAD_PROCESS_PRIVATE 或 PTHREAD_PROCESS_SHARED.``int` `pthread_spin_init(pthread_spinlock_t *lock, ``int` `pshared);` `int` `pthread_spin_destroy(pthread_spinlock_t *lock);` `int` `pthread_spin_lock(pthread_spinlock_t *lock);` `int` `pthread_spin_trylock(pthread_spinlock_t *lock);` `int` `pthread_spin_unlock(pthread_spinlock_t *lock);`

- 条件变量

  `pthread_cond_t cond = PTHREAD_COND_INITIALIZER;` `int` `pthread_cond_init(pthread_cond_t *restrict cond,``          ``const` `pthread_condattr_t *restrict attr);` `int` `pthread_cond_destroy(pthread_cond_t *cond);` `// 调用wait前需要先lock mutex.``// wait 的行为可以分为几步: 先将线程放入条件变量的等待队列, 再unlock mutex. 当收到通知时,``// 尝试lock mutex, 获得锁后就返回, 程序继续执行.``// 最好在wait返回后再次检查条件是否满足.``int` `pthread_cond_wait(pthread_cond_t *restrict cond,``          ``pthread_mutex_t *restrict mutex);` `int` `pthread_cond_timedwait(pthread_cond_t *restrict cond,``            ``pthread_mutex_t *restrict mutex,``            ``const` `struct timespec *restrict abstime);` `int` `pthread_cond_signal(pthread_cond_t *cond);` `int` `pthread_cond_broadcast(pthread_cond_t *cond);`

  使用例子:

  `pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;``pthread_cond_t cond = PTHREAD_COND_INITIALIZER;` `int` `i = ``0``;` `void` `reader()``{``  ``for``(``int` `i = ``0``; i < ``10``; ++i)``  ``{``    ``pthread_mutex_lock(&lock);``    ``while``(i <= ``0``)``    ``{``      ``pthread_cond_wait(&cond, &lock);``    ``}``    ``// process read``    ``--i;``    ``pthread_mutex_unlock(&lock);``  ``}``}` `void` `writer()``{``  ``for``(``int` `i = ``0``; i < ``10``; ++i)``  ``{``    ``pthread_mutex_lock(&lock);``    ``// process write``    ``++i;``    ``pthread_cond_signal(&cond);``    ``pthread_mutex_unlock(&lock);``  ``}``}`

- 内存屏障

  `int` `pthread_barrier_init(pthread_barrier_t *restrict barrier,``             ``const` `pthread_barrierattr_t *restrict attr,``             ``unsigned count);``int` `pthread_barrier_destroy(pthread_barrier_t *barrier);``int` `pthread_barrier_wait(pthread_barrier_t *barrier);`

## Linux内核的同步方式

在内核中, 可能存在多个内核执行流, 因此需要同步对共享数据的访问, 特别是在多处理器系统中.

- **原子操作**: 操作绝不会被其他事件打断, 需要硬件的支持.
- **信号量**: 减1之后若信号量值小于0, 进程就阻塞在该信号量上, 否则可以运行, 进程释放信号信号量时对其加1.
  当信号量值大于负数时表明可以调度等待进程.
- **读写信号量**
- **自旋锁**
- **大内核锁(big kernel lock, BLK)**: 利用自旋锁实现, 但是支持一个进程递归地获得锁,
  释放次数等于获取次数时锁才会被释放. 大内核锁用于保护整个内核, 因此内核中只有一个BLK.
  进程持有BLK时如果被取消调度, 其BLK也会被释放, 再次获得调度时, 会重新获得BLK.
- **读写锁**
- **大读者锁(brlock, big reader lock)**: 比读写锁的性能更好, 读者可以快速地获得锁, 而写者获得锁的开销较大.
  实现机制是每个大读者锁都在所有CPU上有一个本地读者写者锁, 读者仅需要获取本地CPU的读者锁,
  而写者必须获得所有CPU上的锁.
- **读-拷贝修改(read-copy update, RCU)**: 读写锁的高性能版本, 比大读者锁具有更好的扩展性和性能.
  对于被RCU保护的共享数据结构, 读者不需要获得任何锁就可以访问它, 但写者在访问它时首先拷贝一个副本,
  然后对副本进行修改, 最后使用一个回调机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据,
  这个时机就是所有引用该数据的CPU都退出对共享数据的操作.
- **顺序锁(seqlock)**: 允许读写操作同时进行, 不能同时进行多个写操作. 读操作期间如果发生写操作,
  需要重新读. 适合读写操作同时发生的概率比较小的情况.

### 优化和屏障

编译器和CPU为了效率会重排程序指令, 为了防止出现问题, 提供了屏障. 分为**优化屏障**和**内存屏障**.

- 优化屏障: 保证编译器不会混淆放在原语操作前和原语操作后的指令.

- 内存屏障: 对CPU的指令重排做出限制, 分为读屏障, 写屏障, 读写屏障, 如下(来自

  知乎

  ):

  - 读屏障作用于Invalidate queue, 每次cpu遇到这个指令都将自己积压已久的invalidate ack处理掉.
    具体就是使得对应的缓存失效, 这样自己再读的时候, 能保证读到最新的副本.
  - 写屏障作用于store buffer, 将处于store buffer中的写操作真正执行掉.
    具体就是向其他CPU发送invalidate cache 的消息, 写自己的独占缓存.
  - 全能型屏障这两件事都做.

## 系统编程

- read, write: 返回-1时都表示出错. read 成功时返回读到的字节数, 当读到文件尾时, 返回0;
  write 成功时返回已写的字节数, write 成功返回仅仅表示数据写到了缓冲区.
  read和write在内核的实现基本类似, 下面介绍其步骤:

  1. 从 fd 获取**文件对象**地址. 每次调用 open 都会生成一个文件对象, 文件描述符表中的元素指向了对应的文件对象.
  2. 检查文件对象中的权限, 能否进行读/写. 权限不满足就返回错误.
  3. 检查文件对象是否提供了读/写操作, 没有就返回错误.
  4. 验证参数, 保证提供的内存地址空间(缓冲区)在用户地址空间.
  5. 检查文件锁是否冲突.
  6. 调用文件对象的读/写函数来进行实际的操作. 此时文件偏移将会被更新.
  7. 释放文件对象, 返回实际读/写的字节数.

- creat: 等价于 open(path, O_WRONLY|O_CREAT|O_TRUCT, mode).

- 下面的函数用于复制一个文件描述符, 返回一个值不同, 但是与旧的fd等价的文件描述符, 旧的fd仍然有效.

  `// dup 返回当前可用的fd的最小值.``int` `dup(``int` `oldFd);` `// dup2 用 newFd 指定新的描述符的值, 返回新的的描述符的值.``// 如果 newFd 已经打开, 就先将其关闭, 并且保证关闭和重新使用不会被打断, 是一个原子操作,``// 因此不等价于先关闭 newFd, 再调用 dup.``// 如果 newFd == odlFd, 程序不做任何事.``// 除了上面两种情况, newFd 的 FD_CLOEXEC 标志都会被清除, 这样进程在 exec 后 newFd 仍然打开.``int` `dup2(``int` `oldFd, ``int` `newFd);` `// 除了下面两点, 等价于 dup2:``// 1. 可以通过 flags 显式设置 FD_CLOEXEC 标志.``// 2. 当 oldFd == newFd 时, 函数失败.``int` `dup3(``int` `oldFd, ``int` `newFd, ``int` `flags);`

- 内核设有缓冲区, 大多数磁盘IO都通过缓冲区进行. 当向文件写入时, 内核通常先将数据复制到缓冲区,
  然后排入队列, 晚些时候再写入磁盘. 这种方式称为**延迟写(dealyed write)**.
  为了保证数据及时写入到磁盘磁盘, 提供了下面几个函数, 返回 0 时表示成功, 返回 -1 时表示失败:

  `// 将所有修改过的块缓冲区排入写队列, 然后返回, 不等待实际写操作结束.``void` `sync();` `// 类似于 sync, 但是只针对 fd 指定的文件.``int` `syncfs(``int` `fd);` `// 只针对 fd 指定的文件, 等待磁盘写操作结束才返回. 更新文件的数据和属性.``int` `fsync(``int` `fd);` `// 类似于 fsync, 但是只更新文件的数据.``int` `fdatasync(``int` `fd);`

- 获取时间的函数, time和gettimeofday都返回墙上时间, 并且当系统时间被更改时, 得到的值也会受影响.
  例如可能后面的命令返回的时间比前面的早, 因此不能用他们来测量一段时间的长度(例如操作花了多久),
  而应该使用 clock_gettime, 并将第一个参数设为 CLOCK_MONOTONIC.

  `// 返回Unix时间, 参数不为NULL时也会写到对应变量中. 精确到秒.``time_t time(time_t *calptr);` `// tzp 必须设为 NULL. 精确到毫秒.``int` `gettimeofday(struct timeval *restrict tp, ``void` `*restrict tzp);` `// 获取指定时钟的时间, 写到 tsp 中. 成功返回 0, 否则返回 -1. 精确度可能更高, 最高到纳秒,``// 前提是系统支持.``int` `clock_gettime(clockid_t clock_id, struct timespec *tsp);`

- 程序执行C语言程序时, 在执行 main 函数之前, 会先执行一个特殊的**启动例程**, 用于从内核获得命令行参数和环境变量等,
  然后调用 main 函数. 一般是:

  `exit(main(argc, argv)); ``// 将 main 返回值作为 exit 参数.`

- 程序有 8 种终止方式, 其中 5 种是正常终止, 分别是:
  从main返回; 调用 exit; 调用 _exit或_Exit; 最后一个线程从其启动例程返回; 从最后一个线程调用 pthread_exit;
  3 种是异常终止, 分别是: 调用 abort; 接到一个信号; 最后一个线程对取消请求做出响应.

- 不论进程如何终止, 最后都会执行一段相同的内核代码以关闭进程的打开文件描述符, 释放使用的存储器.

- 几种退出函数:

  `// 等价于 return 语句, 会调用 _exit. 先执行清理操作, 再返回内核. 操作有:``// 1. 调用终止处理程序(用atexit注册).``// 2. 关闭IO流.(不一定)``void` `exit(``int` `status);` `// 下面两种都是直接返回内核, 但是属于进程的打开文件描述符都会被关闭.``// 可能会清理IO流, 由实现决定.``void` `_exit(``int` `status);``void` `_Exit(``int` `status);`

- 下面的函数用于动态申请/释放内存, 其中 brk 和 sbrk 是系统调用, 用于改变进程堆的大小.

  `// malloc, calloc, realloc 都是用 brk/sbrk 实现的.` `// 1. 当用 malloc 申请的内存超过一定大小时(MMAP_THRESHOLD, 一般是128kB), 会调用 mmap 来分配空间.``// 2. 对于多线程环境, 为了减少多个线程申请内存时发生的竞争, malloc 维护多个堆区域, 称为 arena,``// 不同线程在不同 arena 获取内存. 一般限制arena个数为核心数的8倍, 此限制同样可以修改.``// 3. malloc 是线程安全的, 不是可重入的.``// 前者是因为 malloc 的实现中采用了锁, 能保证不会发生冲突, 这样的实现也导致了后者.``// 例如当执行 malloc 时, 如果接收到信号, 执行信号处理函数时又调用了 malloc, 就很可能会发生死锁, 因为 malloc 使用的锁是非嵌套的.``// 如何避免这个问题呢: 要尽量简化信号处理函数, 不要在其中做太多工作. 例如可以简单的设置一个标志, 用户代码检测到标志时进行处理工作.``// 4. 具体 glibc malloc 的实现可以参考: https://sourceware.org/glibc/wiki/MallocInternals``void``* malloc(size_t size);``void``* calloc(size_t nobj, size_t objsize);``void``* realloc(``void` `*ptr, size_t new_size);` `// free的参数必须是malloc等函数的返回值, 不能对malloc的返回值增减之后再来调用free.``void` `free(``void` `*ptr);` `// brk 将进程的堆的地址增长到 addr 指定的位置. 成功返回 0, 否则返回 -1.``int` `brk(``void` `*addr);` `// sbrk 将进程的堆增长 increment bytes. 返回增长前堆的末尾的地址, 即增长的内存的起始地址,``// 发生错误时返回 (void*)-1.``void``* sbrk(intptr_t increment);`

- 创建新的进程的接口, 都利用 _do_fork 实现, 在 linux/kernel/fork.c 文件中.
  Linux 在内核中为每个进程维护一个 task_struct 数据结构以保存进程的所有相关信息, 其中包含: 进程状态, pid, 打开文件描述符表指针等.
  linux 中线程的实现类似于进程, 同样会为每个维护一个 task_struct. 主线程的 task_struct 就是进程的 task_struct.
  可以通过 task_struct 中的 tgid 字段识别是否是主线程, 主线程的 tgid 与 pid 相等.

  `// 父进程的虚拟地址空间都会被复制, 包括锁等.``// 为了提高效率, 并不立即复制父进程的数据段, 堆, 栈, 而是使用写时复制(COW).``// fork 后子进程还是父进程先运行是不确定的.``// IO缓冲区中的内容也会被复制到子进程中.``// 父进程的所有打开文件描述符都被复制到子进程中, 父子进程共享文件对象, 看到的文件状态(如偏移)是一致的.``//``// fork后父子进程的区别包括:``// 1. fork返回值, 进程id, 父进程id``// 2. 子进程不继承父进程的文件锁.``// 3. 子进程的未处理闹钟被清除, 未处理信号被设为空集.``//``// fork失败的原因一般是: 系统进程过多 or 实际用户的进程超过系统限制.``//``// fork得到的子进程是单线程的, 并从fork语句开始运行. 可以用 pthread_atfork 函数来处理多线程时资源的释放(如锁).``// 父进程是多线程时, 子进程一般fork后就直接调用 execve.``//``// 内核可能倾向于让子进程先运行, 其好处是: 因为一般子进程会马上调用 exec 函数, 这样可以避免写时复制的开销.``// 如果父进程先运行, 可能会在 fork 之后写地址空间, 引起写时复制, 而实际上这个复制很可能是不需要的,``// 因为子进程不会用到这些地址空间.``pid_t fork();` `// 不会将父进程的地址空间复制到子进程, 在子进程中应该立即调用 exec 或 _exit, 以避免引用父进程地址空间.``// 在调用 exec 或 _exit 之前, 子进程运行在父进程的地址空间, 因此对变量的修改, 函数的调用会带来未知的结果.``// vfork 保证子进程先运行, 只有当子进程调用 exec 或 _exit 后父进程才会继续运行.``// 注意: 不能用 exit 代替 _exit, 前者会导致 exit handler 被调用, 并且会冲洗 io 缓冲区.``pid_t vfork();` `// 创建进程, 执行 fn 指定的函数, arg 为传给函数的参数, child_stack 指定了进程的堆栈起始地址,``// flags 指定创建的进程的相关属性. 线程的创建就是基于 clone.``// clone 可以与父进程共享地址空间, clone 创建出的进程可以是子进程/兄弟进程.``int` `clone(``int` `(*fn)(``void` `*), ``void` `*child_stack, ``int` `flags, ``void` `*arg, ... /* pid_t *ptid, ``void` `*newtls, pid_t *ctid */);`

- 当一个进程终止时, 内核会为其保存部分信息, 如进程ID, 终止状态等, 父进程可以通过 wait/waitpid来获取这些信息.

- 一个进程的父进程已终止时, 内核将其父进程设为 init 进程(进程号是 1).

- 僵尸进程: 一个已经终止, 但是父进程尚未对其进行善后处理(获取其状态, 释放占用的资源)的进程称为僵尸进程.

- 非阻塞IO: 在 open 时指定 O_NONBLOCK 标志; 对于已经打开的文件, 可以用 fcntl 打开 O_NONBLOCK 标志.

  `oldFlag = fcntl(fd, F_GETFD, ``0``);``oldFlag |= O_NONBLOCK;``fcntl(fd, F_SETFD, oldFlag);`

- **记录锁(record locking)**: 对文件的一部分加锁, 以偏移量指定范围. 可以添加写锁或读锁.
  实现记录锁的方式有: fcntl, lockf, flock.
  系统通过进程 id 来记录进程对记录锁的占用. 因此:
  fork产生的子进程不会继承父进程的记录锁, 因为她有不同的进程ID.
  而exec后进程仍持有记录锁, 因为其进程ID未变.

- **flock**: 进程退出或关闭fd时会自动取消此记录锁. 不同进程分别调用open等函数获得相同文件的fd时,
  记录锁仍然正常作用. 获得锁的进程再次调用flcok获取锁时, 新的锁会代替旧的锁.
  flock 只能锁住整个文件, 而不能针对部分操作.

- wait, waitpid, waitid, wait3, wait4: 获取子进程的终止状态. wait 是阻塞的, waitpid 可以设为非阻塞.

- exec 系列函数.

  第一个参数是 pathname 的表示可执行文件通过路径名指定, 是 file 的如果以 '/' 开头就看做绝对路径,
  否则按 PATH 环境变量搜索文件.
  其中 l/v 的区别在于传递给要执行程序的参数的形式, 前者是通过多个参数指定(list), 这要求最后一个参数是NULL.
  后者是通过一个二维数组指定, 一般将 argv[0] 设为可执行文件的文件名.
  以 e 结尾的函数向可执行程序传递环境变量.
  这些函数最终都是通过 execve 实现的.

  `int` `execl(``const` `char` `*pathname, ``const` `char` `*arg0, ... /* (``char` `*)NULL */);``int` `execv(``const` `char` `*pathname, ``char` `*``const` `argv[]);``int` `execle(``const` `char` `*pathname, ``const` `char` `*arg0, ... /* (``char` `*)NULL */, ``char` `*``const` `envp[]);``int` `execve(``const` `char` `*pathname, ``char` `*``const` `argv[], ``char` `*``const` `envp[]);``int` `execlp(``const` `char` `*file, ``const` `char` `*arg0, ... /* (``char` `*)NULL */);``int` `execvp(``const` `char` `*file, ``char` `*``const` `argv[]);``int` `fexecve(``int` `fd, ``char` `*``const` `argv[], ``char` `*``const` `envp[]);`

- 线程控制函数. 一般线程终止时, 会保存部分状态信息, 直到其他线程对其调用 pthread_join.
  除非线程被分离.

  `// 创建线程, 从函数 fn 开始执行. 不能保证新旧线程的运行顺序. 新线程的线程id保存在 tidp.``int` `pthread_create(pthread_t * tidp, ``const` `pthread_attr_t * attr, ``void` `*(*fn)(``void` `*), ``void` `*arg);` `// retval 是传给其他线程的参数, 其他线程可以通过 pthread_join 函数获得.``void` `pthread_exit(``void` `*retval);` `// 等待指定线程终止, retval 指定的内存将保存 pthread_exit 的参数.``// 当目标线程被取消时, 该值被设为 PTHREAD_CANCELED.``// 如果线程已被分离, 调用会失败.``int` `pthread_join(pathread_t thread, ``void` `**retval);` `// 分离指定线程. 线程终止时底层资源会被立即释放, 不能对其调用 pthread_join.``int` `pthread_detach(pthread_t thread);`

- aio_read, aio_write: 异步io的读写.

- 存储映射IO

  mmap并不会立即将文件复制到内存中, 而是先分配虚拟地址空间, 并创建一个数据结构来维护这段虚拟地址空间.
  数据结构保存了这段的起始位置, 结束位置和其他相关参数. 多个mmap区域对应的数据结构被组织为一个链表.

  当程序访问该该段地址空间时, 产生一个缺页中断, 内核此时才会将文件对应页的数据复制到内存页.
  用 read 接口访问文件时, 需要先将文件复制到内核的内存空间, 再复制到用户的内存空间. 需要一次磁盘读取加一次内存复制.
  而 mmap 直接将数据从磁盘复制到用户内存空间, 只需要一次磁盘读取加一次缺页中断.

  `// 将 fd 和 offset 指定文件的部分映射到 addr 和 len 指定的内存区域，addr 可以设为 NULL，由系统决定放置位置。``// prot 指定了对内存区域的访问权限。``// 在映射之前必须保证文件已经打开，映射之后关闭 fd 不会导致映射区域关闭。``// 对映射区域的写操作，由内核决定何时更新到磁盘。``void``* mmap(``void``* addr, size_t len, ``int` `prot, ``int` `flags, ``int` `fd, off_t offset);` `// 主动关闭映射区域。进程终止时也会关闭映射区域。关闭映射区域不会使得映射区域的内容写到磁盘。``int` `munmap(``void``* addr, size_t len);` `// 将已修改的页更新到文件。``int` `msync(``void``* addr, size_t len, ``int` `flags):`

## 文件系统

### 文件

文件类型分为下面几种:

- 普通文件

- 目录文件

- 设备文件: 分为下面两种. 设备文件都有主设备号和次设备号, 前者表明设备类型, 说明设备应该使用的驱动程序,

  后者指明具体的设备.

  - 块特殊文件: 设备文件的一种, 支持随机访问, 提供缓冲. 如硬盘.
  - 字符特殊文件: 设备文件的一种, 一般不支持随机访问, 不提供缓冲.

- FIFO

- 套接字

- 符号链接

文件权限位有 set-group-id 位 和 set-user-id 位, 其作用是当执行此文件时，将进程的有效用户/组id设为文件的所有者的id/组所有者的id。

进程创建一个新文件时，文件所有者为进程的有效用户，而文件的组所有者为进程有效组或所在目录的组。

如果对目录设置了**粘着位(saved-text bit)**, 只有对该目录有写权限并且满足下面某一个条件,
才能删除或重命名目录下的文件.(在rwx形式的文件权限表示中在最后, 用t表示)

- 拥有此文件
- 拥有此目录
- 是root

文件权限的含义, 特别是目录文件.

新创建的文件的属主ID为创建文件进程的有效用户ID.
组ID默认是进程的有效组ID, 若新文件所在目录设置了 set-group-ID 位, 则组ID是目录组ID.

### VFS

linux可以使用不同的文件系统, 其实现是在用户和文件系统中增加了一层**虚拟文件系统(VFS)**, 以此引入一个通用的文件模型.
因此, VFS(或者Linux内核)不能对一个诸如read, write这样的函数进行硬编码, 因为不同的文件系统需要不同的实现方式.
所以, Linux要求每个文件系统实现自己这些函数, 然后提供一个操作列表, 在用户通过VFS进行系统调用时,
内核检查文件是否实现了对应的函数, 如果支持, 就调用该函数来执行实际的操作.

### 进程打开文件如何关联到磁盘文件

内核为每个进程维护一个**文件描述符表**, 表项记录了对应 fd 的文件指针, 他指向一个文件对象. fd 实际上是表项的下标.

**文件对象**是内核维护的, 记录了所有进程打开的文件(不同进程打开同一文件对应不同文件对象),
其中包含文件状态标志, 当前偏移量, 文件对应v节点指针. v节点指针指向一个v节点表项.
当关闭(如调用 close)打开的文件描述符时, 会将文件描述符表中对应的项置为无效, 并删除对应的文件对象.

fork产生的子进程有独立的文件描述符表, 但是文件指针的值与父进程的相同. 即子进程与父进程共享同一个文件对象,
此时如果在子/父进程中关闭对应的文件描述符, 并不会立即删除对应的文件对象, 父/子进程中还能继续使用该文件.
这是因为文件对象维护了一个**引用计数**, 只有当计数为0时才会释放该文件.

**v 节点表项**是Linux虚拟文件系统建立的, 用于维护通用的文件结构. 包含一个i节点指针, 指向对应的i节点.
系统中每个文件只对应一个 v 节点.

**i节点**包含文件的具体信息, 如长度, 数据所在磁盘位置等. i 节点是文件系统相关的.

Linux中用**通用i节点**替代 v节点.

## 中断

中断可以导致系统从用户态转为内核态, 分为三种:

- 用户程序调用系统调用引起的**软件中断**
- 由外部设备产生的**硬件中断**
- 代码执行出错(如除0)导致的**异常**

### 软件中断

linux中的每个系统调用都有一个**系统调用号**, 用户进程通过系统调用号来通知系统调用哪个系统调用.
一旦系统调用号被分配, 就不能再分配给其他系统调用. 有时候某些系统调用会被取消, 此时这些系统调用号就无效了.
linux专门定义了一个系统调用, 这些**无效的系统调用号**都对应该系统调用, 该系统调用只是简单的返回 -ENOSYS,
表明系统调用无效, 不做其他工作.

用户进程调用系统调用时, 会触发一个**软件中断**, 一般是第128号软中断. 这个中断会使得系统转到内核态,
并执行对应的中断处理程序 system_call(). system_call() 根据对应用户给的系统调用号调用对应的系统调用,
在调用返回后, 就切换回用户空间, 让用户进程继续执行.

### 硬件中断

由硬件产生, CPU收到硬件中断后, 就会通知操作系统. 每个硬件中断有一个对应的中断号(例如 1 是键盘中断),
并且对应一个**中断处理程序**(interrupt handler, 也叫中断服务例程, interrupt service routine, ISR),
设备的中断处理程序是设备驱动的一部分.

一般将中断处理程序分为前后两部分(top half, bottom half), 在执行前面一部分(top half)时会禁止所有中断,
做一些有严格时限的工作, 此时ISR的执行不会被其他中断打断. 在执行后一部分(bottom half)时则可以允许其他中断, 允许被打断.

在早期的linux中, ISR是在被打断进程的内核栈运行的(总会有一个进程在运行, 即使没有进程可以调度, 也会运行一个定义的空任务),
而在2.6之后, 每个处理器拥有一个中断栈(一般是一页)专门用于执行中断处理程序.

中断的处理流程为:

1. 硬件终中断到达中断控制器, 后者检查该中断是否被屏蔽.
2. 中断到达CPU.
3. 系统跳转到一个预定义的内存位置, 执行预定义的指令.
4. 屏蔽相同的中断, 检查是否有对应的ISR.
5. 如果有执行对应的ISR, 如果没有就直接转到下一步.
6. 处理善后工作, 例如检查是否需要调用 schedule(), 返回被中断处.

### 异常

## 其他

- 用户态和内核态

  执行用户地址空间的指令时, 称处于**用户态**. 当执行内核指令时, 处于**内核态**. 用户态只能执行非特权指令,
  需要通过转入内核态, 由内核来执行特权指令.

  系统调用, 异常, 外围设备中断会导致系统进入内核态.

  **系统调用**: 例如内存分配, 标准库中的 malloc 就是对系统调用 sbrk 的封装. 执行系统调用时会转入内核态.

  **异常**: 例如缺页异常. 发生异常时, CPU会暂停当前程序, 转入内核态, 去执行中断信号处理程序.

  **外围设备中断**: 由外围设备向CPU发出中断信号, 此时CPU会暂停当前程序, 转入内核态, 去执行中断信号处理程序.

  从用户态转入内核态时, 系统需要先保存进程上下文, 切换内核堆栈, 更新寄存器, 将权限修改为0级(特权级, 即进入内核态), 转而去执行对应的指令.
  恢复到用户态时, 通过保存的上下文更新堆栈, 寄存器等, 继续执行指令.

- Linux开机启动

## 问题

- 多进程的TCP服务端，能否互换fork()与accept()的位置？

- 多个进程/线程能否绑定到同一端口?

  可以. Linux提供了 *SO_REUSEPORT* option, 调用 setsocketopt 函数设置套接字的 option 即可.
  所有监听该端口的进程/线程都需要设置 *SO_REUSEPORT*, 为了保证安全性, 第一个bind进程后的所有进程必须与第一个进程具有相同的 effective uid.
  多个进程/线程绑定到同一端口后, 如果对其调用accept, 这些进程会阻塞在相同的阻塞队列中.
  此时如果有一个connect请求进来, 内核会唤醒其中的一个进程/线程. 这能在一定程度上实现负载均衡.

  值得一提的是: 连接是通过client和server的 ip+port 来确定的, 假设server设置了 SO_REUSEPORT,
  如果client端的ip, port也都相同, 那么所有的数据包都会发送给对应的进程.

  关于该 option 的具体讨论可以参考 [LWN: The SO_REUSEPORT socket option](https://lwn.net/Articles/542629/).

  另一个值得一提的是 *SO_REUSERADDR* option. 传统的网络服务器使用的就是此 option 来实现: 一个进程负责 accpet,
  accept 之后, 创建一个子进程来负责具体的任务. *SO_REUSERADDR* 的具体作用为:

  - 即使一个端口上存在连接(即正在被使用), 也允许一个进程/线程(后面都简写为进程) bind, listen 该端口.
    这是处理这样的问题: 当负责监听, 处理连接的进程崩溃时, 需要重启, 再调用 socket, bind, listen,
    此时连接已经存在, 默认会使得 bind 失败, 因此指定此 option.
  - 允许在同一端口上启动多个进程, 只要这些进程绑定到不同的本地ip地址, 这对于多宿主主机用处很大.
  - 允许单个进程绑定同一端口到多个套接字上, 只要不同套接字具有不同的本地ip地址.

- gdb 的原理

  gdb 主要通过系统调用 ptrace 实现. ptrace 可以将 gdb attach 到指定线程, 这有两种方式:

  - 在 gdb 中运行一个进程, 再对其进行调试. 首先利用 fork 创建该进程, 再在子进程中调用 ptrace,
    并将第一个参数设为 PTRACE_TRACEME, 表示此进程将被父进程跟踪, 然后执行 exec 函数.

  - 将 gdb attach 到一个已存在的进程. 指定进程的 pid, gdb 调用 ptrace, 将第一个参数设为 PTRACE_ATTACH,
    将 pid 作为函数参数. 这样, gdb 就成为该进程的父进程, 并跟踪该进程.

    通过这两种方式, gdb 就和被调试进程建立了联系, 即成为其父进程, 该进程被父进程跟踪.
    此时任何传递给该进程的信号(除了SIGKILL)都将通过 wait 方法阻塞该进程, 并将信号转交给父进程.
    并且, 该进程如果调用 exec 函数, 都会接收到一个 SIGTRAP 信号, 使得父进程(gdb)可以在被跟踪进程执行第一条指令前就可以做一些需要的工作.
    这也是第一种实现方式的原理.

  - *断点**是通过内核信号实现的. 增加断点时, 实际是将指定位置写入指令 INT 3. 运行到此指令时,
    会触发 SIGTRAP 信号, 从而被跟踪进程会被暂停, gdb可以捕获到此信号. gdb将断点组织为一个链表,
    此时就可以查询此链表, 检查是否有匹配的断点记录, 当存在时就发生断点命中, 就允许用户做一些调试操作.
    否则继续执行命令.





# 操作系统面试知识点与问题

操作系统的一个主要功能是对设备, 资源的管理, 主要包括:

- cpu
- 内存
- 外存
- 键盘, 鼠标, 显示器等设备

那对应的可以将操作系统分为几个部分, 分别管理各类资源:

- 进程调度
- 进程间通信
- 内存管理
- 文件系统
- IO管理

## 知识点

### 进程, 线程, 协程

#### 区别

- 进程就是正在执行的程序, 每个进程有独立的地址空间.
- Unix/Linux中存在进程的层次结构, 进程和它所有的子进程(包括间接的)组成一个进程组.
  在Windows中不存在进程的层次结构, 父进程在创建子进程时可以得到子进程的句柄, 通过句柄来控制子进程, 并且句柄可以传送给其他进程.
- 进程用于将资源集中到一起, 线程是CPU调度的单位.
- 一个进程的所有线程共享地址空间, 但是每个线程具有独立的: 程序计数器, 寄存器, 栈, 状态.
  对于栈, 每个线程的堆栈有一帧, 保存了线程的函数调用栈.
- 协程是用户态的轻量级线程, 其调度由用户控制, 共享进程的地址空间. 协程有自己的栈和寄存器, 在切换时需要保存/恢复状态.
  切换时减少了切换到内核态的开销. 一个进程和线程都可以有多个协程. 相比函数调用, 协程可以在遇到IO阻塞时交出控制权,
  进程还拥有自己调度协程的能力.

#### 调度

- 轮转调度: 每个进程运行一段给定时间, 称为时间片.
- 优先级调度: 为每个进程赋予一个优先级, 优先级高的先调度. 为了防止饥饿, 可以设置进程的最大时间片,
  还可以动态调整进程的优先级(例如等待时间越长, 优先级越高).
- 多级队列: 根据进程执行的任务的变化, 设置不同的优先级. 例如给等待用户输入的进程更高的优先级,
  当进程等待磁盘IO时, 降低优先级.

#### 死锁

- 当多个进程之前出现循环等待时, 每个进程都在等待进程组中其他进程, 因此这些进程都无法继续运行. 称之为死锁.
- 安全状态: 定义了各个进程占有的资源数, 要请求的资源数, 系统剩余资源数. 从安全状态出发, 存在一个调用顺序,
  使得所有进程都可以得到请求的资源数, 即所有进程都可以执行完.
- 银行家算法: 基于安全状态的定义, 保证每一次资源分配之后, 系统都处于安全状态.

死锁处理主要从两个方面着手: **死锁预防**和**死锁检测**.

**死锁预防**指在死锁发生之前通过某些方法避免死锁发生. 有下面两种方式:

- 对加锁请求进行排序或要求同时获得所有锁, 以此保证不会发生循环等待. 难以实现或降低了系统效率.

- 当有可能发生死锁时, 进行事务回滚. 例如事务请求的锁被其他事务占用时, 将其中一个事务回滚, 让另一个事务继续执行.

  一般是较早执行的事务具有较高优先级. 这种机制都是基于时间戳, 例如用时间戳表示事务的开始时间,

  时间戳小的事务更老. 可分为两类:

  - **wait-die** 机制: 非抢占, 当事务 T_{i}*T**i* 请求的锁被事务 T_{j}*T**j* 占用时, 如果 T_{i}*T**i* 时间戳小于 T_{j}*T**j* 的,
    说明 T_{i}*T**i*​ 更老, 允许 T_{i}*T**i*​ 等待. 否则 T_{i}*T**i*​ 回滚.
  - **wound-die** 机制: 抢占式, 当事务 T_{i}*T**i* 请求的锁被事务 T_{j}*T**j* 占用时, 如果 T_{i}*T**i* 时间戳小于 T_{j}*T**j* 的,
    说明 T_{i}*T**i*​ 更老, T_{j}*T**j*​ 会回滚, 释放占用的锁, T_{i}*T**i*​ 得到请求的锁. 否则允许 T_{i}*T**i*​ 等待.

**死锁检测**允许系统发生死锁, 并用死锁检测和**死锁恢复**机制使系统恢复正常状态. 系统周期性地运行死锁检测算法,
以判断是否发生死锁, 如果发生, 就尝试从死锁恢复. 死锁检测可以用**等待图**来实现, 即维护事务的拓扑排序,
当发现环时就发生了死锁. 死锁恢复通常是回滚一个或多个事务, 这涉及到:

- 选择牺牲者: 回滚哪些事务的代价最小.
- 回滚: 事务是回滚到最初是状态, 还是回滚部分.
- 饿死: 如果一个事务总被作为牺牲者, 就会发生饿死现象. 如何避免. 常用方法是在回滚代价中考虑已回滚次数.

### 内存管理

首先区分**物理内存**和**虚拟内存**:

- 物理内存: 指实际的内存, CPU使用**物理地址**来访问主存中的数据.
- 虚拟内存: 每个进程都有自己的虚拟地址空间, 其地址是**虚拟地址**, 进程使用虚拟地址来访问数据.
  实际访问内存时, 由MMU将其映射为物理地址.
  - MMU: 用于将虚拟地址转换到物理地址.

为了应对**内存碎片**问题, 使用**分页机制**来管理内存:

- 分页: 将内存(物理内存和虚拟内存)划分为大小相等(如4KB)的页, 将其作为内存分配的单位.
- 页表: 记录了虚拟地址到物理地址的映射. 由连续的, 等长的项构成. 每项记录了实际的页地址, 以虚拟的页地址作为索引.
  为了降低页表占用的空间, 还可以采用多级页表. 每个进程都有独立的页表, 进程的用一个页目录基址指针指向了自己的页表.
- 多级页表: 将虚拟地址划分为多个部分, 每个部分对应一级页表, 逐层搜索. 一般让一级的一个页表正好占据一页.
  这是因为在 64 位机器下, 很多的虚拟地址空间没有被用到, 记录这些虚拟地址映射的页表是无用的, 但是却会占据大量的内存空间.
  为了节省页表占据的内存空间, 多级页表应运而生.

那么如何实现**虚拟地址到物理地址的映射**呢?

1. 进程将虚拟地址传递给CPU, CPU将其传递给MMU.
2. MMU首先检查**TLB**, 如果存在该虚拟地址的映射, 直接返回该映射.
3. 如果不存在, 就访问页表. 首先通过进程的页表基址和虚拟地址计算页表项的物理地址, 然后就访问内存, 取出页表项. 并将其放置到TLB.
4. 得到映射/页表项之后, 如果对应的数据没有存储到内存, 就引起一次**缺页中断**, 将对应内容放置在内存中.
5. 将物理地址传递给主存, 主存返回对应数据.

注意几点:

- 上面说到的CPU访问主存, 实际上CPU一般是访问缓存, 当缓存未命中时缓存再去访问主存, 将数据放置到缓存中.
  注意一点, 页表和进程数据都是可以被缓存的.
- 缺页中断/page fault: 指虚拟地址指示的页不在内存中的情况. 当内存不足时, 需要将页面换出, 将指示的页面换入.
  如果换出的页面没有被修改, 可以直接抛弃, 否则还需要写回磁盘. 选择什么样的**换出策略**对内存访问效率非常重要.
- TLB: MMU中的一个部件, 用于缓存经常被用到的虚拟页面的映射, 其中记录了虚拟页号到实际页号的映射.
  在进行虚拟地址的转换时: 首先使用TLB, 看是否有匹配的, 如果有就可以快速返回, 没有则需要正常的地址转换, 并更新TLB.
  注意一点, TLB可以同时查找其中的所有表项, 不需要逐个匹配, 因此速度很快.
- 倒排页表: 前面的页表以虚拟地址为索引, 当虚拟地址空间很大时(如64位机中), 即使使用多级页表也会占据很大空间.
  因此可以以实际内存地址作为索引, 每项保存该物理页号对应的虚拟页号. 但是这导致虚拟地址转换需要搜索整个页表,
  需要的时间很长. 一个解决办法是增大TLB, 另一种是使用散列表, 用虚拟地址来进行散列, 散列结果作为索引.
  散列的方法可以保证平均的地址转换时间.
- 缺页中断分为**软缺页中断**和**硬缺页中断**:
  - **软缺页中断**: 程序访问某个地址时, MMU发现对应页不在内存中, 而实际上页在内存中, 只是没有与该程序的虚拟地址关联.
    例如当多个程序共享某一库时, 操作系统为某一程序加载该库到内存中, 另一个程序访问该库时, 就可以直接使用该库(当该页没有被修改).
    再比如页已被CPU从工作集移除, 但是还没有被写回到磁盘, 而是保存在内存中, 此时程序再次访问该页时就可以直接利用该页.
  - **硬缺页中断**: 程序页缺失, 没有被加载到内存中.

下面再介绍**页面置换算法**, 即内存不足时, 操作系统应该选择将什么页换出.

- 最近未使用(not recently used, NRU)

  页分为四类:

  1. 未被访问, 未被修改.
  2. 未被访问, 已被修改.
  3. 已被访问, 未被修改.
  4. 已被访问, 已被修改.

  当进行页面被读/写时, 记录其被访问, 当页面被写时, 记录其被修改. 访问位可以每隔一段时间清空,
  以便区分出最近访问的页面. 当需要换出页面时, 从最小的非空类中随机选择一页.

- 先进先出(FIFO)

- 第二次机会(second chance)

  基于FIFO, 但是为每个页维护一个访问位, 当页面被加入内存时, 设置该位. 当要换出时, 检查队列头部的页,
  如果访问记录为1, 就将其移到队尾, 清除访问位, 继续寻找下一个队首.

- 时钟页面

  思想和**第二次机会**一样, 但是不使用队列, 而是将记录维护为一个环形链表, 用一个指针遍历此环形链表.
  减少了队列操作带来的代价.

- 最近最少使用(least recentlt used, LRU)

  实际上是最近未使用, 即将已经缓存的最长时间没有使用的页面换出. 一般采用链表队列实现:

  - 当数据被加入到缓存时, 加入到队列末尾.
  - 当访问一个缓存时, 将其移动到队列末尾.
  - 当要换出一个缓存页时, 选择队头的页面.

  **推广的还有 LRU-K 算法**, 这需要记录页最近的使用次数, 当达到 k 次时, 将其缓存. 同样用链表队列维护缓存,
  更新缓存的方式与LRU相同. LUR-K 用访问历史队列记录最近访问的页及其次数:

  - 第一次访问一个页时, 将其加入到访问历史队列末尾, 访问次数记为1. 如果队列已满, 将对头出列(LRU, 也可以用其他算法, 如FIFO).
  - 当访问的页在访问历史队列中时, 将访问次数加一, 并将其转移到队列尾部. 如果访问次数等于 K,
    将该页缓存, 并转移到缓存队列(此时不需要记录访问次数).
  - 缓存队列的维护与 LRU 相同.

另外一个需要考虑的问题是如何来管理内存. 这又可以分为对物理内存的管理和对虚拟内存的管理.

对于物理内存管理, 可以分为对大物理内存的请求和对小物理内存的请求.
对大物理内存的请求, 可以以页框为基本单位, Linux采用**伙伴系统**来实现.
对小物理内存的请求, 采用 **slab 分配器**.

slab是一种对象缓存机制. 内核会为常用的对象(即struct, 如文件对象, task_struct)提前分配空间,
当需要该对象时, 直接将其分配给请求者, 当释放该对象时, 内核将其回收.

对于**虚拟内存管理**, 操作系统需要为每一个进程做独立的内存管理, 一般讨论的是 malloc 等内存分配函数的做法,
也就是说主要是堆内存的管理. 方法包括:

- 隐式空闲链表: 在每个空闲块的开始记录块是否空闲, 块的大小. 通过块大小可以知道下一个块的起始地址.
  此方法寻找空闲块需要线性时间复杂度.
- 显式空闲链表: 每个空闲块还记录了下一个空闲块的起始地址, 这样减少了寻找空闲块的时间, 但是寻找大小匹配的空闲块的时间仍然是线性的.
  其中还有不同的查找算法, 例如首次适应, 下一次适应等等.
- 分离空闲链表: 类似于 linux 部分对 malloc 实现的讨论, 参见该处.

------

经过一段时间之后, 内存中很可能会出现大量不连续的页框. 此时如果进程请求一个大的连续页框, 尽管内存足够,
但是连续内存却不足, 因此不能满足需求. 这个问题有两种解决办法:

- 利用分页单元, 将非连续的空闲页框映射到连续的线性地址空间.
- 利用一种技术尽量避免这种情况.

第一种解决办法有很多缺点:

- 有时候必须要求是连续页框, 如DMA.
- 会导致频繁地修改页表, 增加访存次数, 导致TLB不断刷新.
- 内核有时候使用大的页框效率更高.

因此更倾向于使用第二种方法, 其中一种技术称为**伙伴系统(buddy system)**.
伙伴系统将空闲内存组织为多个链表, 每个链表包含多个大小固定的页框, 大小分别为 1, 2, 4, ..., 1024.

- **分配页**的过程为: 对于请求, 先向上取整使其成为 2^k2*k*, 然后从链表中寻找. 如果对应链表没有页框,
  就可以将其下一个页框分解为两个, 放在当前链表. 如果下一个链表也不足, 再向下搜索. 如果最大的一个还是空的,
  就返回错误(其实可以尝试将前面的页框合并来满足当前请求).
- **释放页**的过程: 将页框加入到对应链表上, 如果链表中存在相邻的, 就可以将二者合并, 并转移到下一个链表上.
  并再次检查是否能够合并, 直到到达最后一个链表.(由于加入页框时会检查是否能够合并, 因此请求失败时不需要检查嫩否合并小的页框, 因为肯定是不能的)

伙伴系统同样适用于虚拟内存的管理.

### 文件系统

- 操作系统不关心文件的内容, 只是将其看做无结构的字节序列.
- 通常每个磁盘都在开始处记录**主引导记录**(MBR, 现在还有GPT), 其后是**分区表**, 记录了各个分区的开始结束位置.
  后面剩余的空间被划分为若干个**分区**, 每个分区可以使用不同的文件系统.
- 每个分区开始是**引导块**, 其中的程序负责将本分区的操作系统装载到内存中, 即使分区不存在操作系统也会保留引导块.
  其后是**超级块**, 包含着文件系统的所有关键参数, 如文件系统类型, 数据块数量等.
  再后面是诸如磁盘空间管理信息, i节点, 数据等等.

#### 磁盘块管理

记录文件用到了哪些磁盘块, 如何分配/释放磁盘块是文件系统的关键任务之一. 下面是一些磁盘块分配方法:

- **连续分配**: 给每个文件分配连续的磁盘块. 这样具有非常好的读性能, 支持随机读写, 但是不利于附加.
  并且容易导致碎片, 浪费磁盘空间.
- **链表分配**: 离散地分配磁盘块, 在每个磁盘块的开头记录文件下一个磁盘块的位置. 连续读写性能较好,
  但是随机存取较慢. 一个微妙的问题是, 由于磁盘开头的记录, 导致磁盘块数据的大小不是2的整数次幂,
  可能会导致存取速度下降, 因为很多程序以2的整数次幂存取文件.
- **在内存中采用表的链表分配**: 维护一个**文件分配表(FAT)**, 文件的第一个磁盘块作为索引,
  每一项记录了当前块的位置和下一块磁盘块的索引.
- **i节点**: i节点大小是固定的, 用一个数组保存文件占用磁盘块, 当文件占用磁盘块数量超过数组大小时,
  数组最后一个元素指向的是保存后续磁盘块地址的磁盘块.

另外一个问题是如何记录空闲磁盘块:

- **空闲表**: 用磁盘块来记录空闲块的地址, 磁盘块最后一个用来记录下一个保存了空闲块地址的磁盘.
  能快速地取得空闲的块, 但是占用空间较多.
- **位图**: 用一位表示磁盘块是否空闲. 取得空闲块时需要搜索位图, 但是所需空间少于空闲表法.

### 中断

包括由外部设备产生的**硬件中断**, 用户程序调用系统接口引起的**软件中断**, 代码执行出错(如除0)导致的**异常**.
中断发生后, 系统转入内核态并保存现场, 通过中断向量表来执行对应处理程序, 分别调用对应的设备驱动程序, 系统调用表, 异常服务例程.
Linux系统现在在执行中断相应的时候, 默认屏蔽其他的中断信号.

#### 硬件中断

外部设备在完成某项任务时, 产生一个中断, 以通知操作系统. 以I/O举例其过程:

1. 操作系统通过设备驱动程序给设备控制器分配任务, 之后CPU就可以开始其他工作, 而不必等待.
2. 在任务完成时, 设备控制器通知中断控制器, 中断控制器根据信号屏蔽状态决定是否响应该信号.
3. 如果中断控制器决定响应, 将会通知CPU, 并将信号编号发送给CPU.
4. CPU一旦决定响应中断, 会先保存现场, 例如将PC, 寄存器等压入堆栈, 然后切换到内核态. 根据信号编号,
   找到对应的中断处理程序, 并执行之. 完成后恢复到之前的状态继续运行.

#### 软件中断

用户程序调用系统接口时产生. 通过中断向量表转向系统调用表, 找到对应的系统调用, 并执行之.

#### 异常

## 常见问题

### 负数, 浮点数的二进制表示

整型负数采用补码表示, 即绝对值的反码加一.

浮点数采用 IEEE754 标准, v = (-1)^{s}*M*2^{E}*v*=(−1)*s*∗*M*∗2*E*. 以32位浮点数为例, 其中:

- s 是**符号位**, 由最高位bit表示. 为0时 (-1)^s = 1(−1)*s*=1, 此时浮点数为正数, 为1时浮点数为负数.
- E 是**指数位**, 由其后 8 个bit表示, 是一个无符号整数, 0 <= E <= 2550<=*E*<=255, 但是实际中指数可以是负数,
  因此规定指数 E 的实际值为指数位的值减去 127, 127 = 255/2127=255/2.
- M 是**有效位**, 由最低的 23 bit表示, 并且 1 <= M < 21<=*M*<2, 也就是说 M 总是以 1.xyz1.*x**y**z* 的形式出现,
  所以在二进制表示中省略了前面的1, 只表示小数点后面的数字. 这样就节省了一个比特,
  以后在翻译时会自动加上1.

指数E还有几种特殊情况:

- E 全为0时: E = 1 - 127 = -126*E*=1−127=−126, 此时在计算有效位时不再加上1. 这是为了表示0而规定的.
  即此时浮点数为 (-1)^s * 0.xyz * 2^{-126}(−1)*s*∗0.*x**y**z*∗2−126. 这也可以用来表现极小值.
- E 全为1时: 如果有效位全为0, 表示正/负无穷大; 如果有效数字不全为0, 这个数是 NaN.

64位浮点数中符号位占 1 bit, 指数位占 11 bit, 最后的有效数字占 52 bit.

### 原子操作的实现原理

原子操作指不可被中断的一个或多个连续操作. 原子操作的实现需要CPU, 主存等硬件的支持.
其中还要认识到多处理器和单处理器在实现上是有巨大差别的, 下面均是针对多处理器. 常见的CPU实现原子操作的原理为:

1. 处理器保证**基本内存操作**的原子性: 例如从内存读取/写入一个字节是原子的, 处理器保证当一个处理器在读取/写入一个字节时,
   其他处理器不能访问该字节. 但是复杂的操作就需要更加复杂的方式来保证原子性了.
2. 使用**总线锁**保证原子性: CPU提供 LOCK # 信号, 当一个CPU在总线上输出此信号时, 其他CPU的请求将被阻塞,
   这就保证只有一个CPU可以访问内存, 从而保证了原子性.
   总线锁使得其他CPU无法访问内存, 而实际上我们只需要保证对某一内存地址的访问是原子的. 这使得总线锁的开销比较大, 因此引入**缓存锁**.
3. 使用**缓存锁**保证原子性: 当数据保存在缓存中时, 利用**缓存一致性**来实现原子性. 但是当数据不能被缓存,
   例如数据跨越多个缓存行时, 就需要使用总线锁定.

**缓存一致性**: 现代的系统中, CPU一般不会直接访问内存, 而是通过缓存, 包括读取和写入, 而写入分为**直写**和**回写**.
直写指的是处理器直接通过缓存将数据写到内存, 回写指的是缓存不会立刻将修改同步到主存, 仅仅是更新缓存的数据.
回写有时具有更高的效率, 因为可以节省写内存的次数, 但是在多处理器系统中却又引发了不一致问题.
在多处理器系统中, 为了保证效率, 我们为每个处理器都配备了自己的缓存, 那么在写回模式下就需要保证各个处理器的缓存的内容是一致的.
常见的算法如MESI算法, 将缓存内容分为四种状态: Modified, Exclusive, Shared, Invalid, 含义分别是:

- Invalid: 内容要么不在缓存中, 要么已经失效/过时. 此段内容无法使用, 需要重新从主存加载.
- Shared: 内容可以使用, 并且和主存内容一致, 多个处理器可以拥有相同的地址的内容, 可以读取, 不能写入.
- Exclusive: 内容可以使用, 并且和主存内容一致, 但是对于一个地址的内容, 如果在一个处理器的缓存中是该状态,
  其他处理器就不能持有该地址的内容. 持有该地址内容的处理器可以对其进行读写.
- Modified: 缓存内容已经被所属的处理器修改, 这导致该地址的内容在其他处处理器上的副本变为Invalid状态.
  如果处理器要抛弃该段缓存内容, 需要先将之写回到主存.



# 操作系统

> 面向进程和线程学习操作系统。

# 目录

|        Chapter 1        |     Chapter 2      |       Chapter 3        |    Chapter 4     |       Chapter 5       |
| :---------------------: | :----------------: | :--------------------: | :--------------: | :-------------------: |
| [进程线程模型](#thread) | [进程间通信](#con) | [同步互斥机制](#mutex) | [存储管理](#mem) | [网络I/O模型](#netio) |

---

# 内容

### <span id = "thread">进程线程模型</span>

线程和进程的概念已经在操作系统书中被翻来覆去讲了很多遍。很多概念虽然都是套话，但没能理解透其中深意会导致很多内容理解不清晰。对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。

**多线程**

我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。我们必须知道，做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。

但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。比如QQ可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。

对于线程，我认为弄清以下两点非常重要：

- 线程之间有无先后访问顺序（线程依赖关系）

- 多个线程共享访问同一变量（同步互斥问题）

另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。

线程相关接口不少，主要需要了解各个参数意义和返回值意义。

1. 线程创建和结束

   - 背景知识：

     在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。

   - 相关接口：

     - 创建线程：int pthread_create(pthread_t *pthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *agr);

       创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。

       - pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t == unsigned long int。

       - attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。

       - start_routine：线程执行函数的首地址，传入函数指针。

       - arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。

     - 获得线程ID：pthread_t pthread_self();

       调用时，会打印线程ID。

     - 等待线程结束：int pthread_join(pthread_t tid, void** retval);

       主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。

       - tid：创建线程时通过指针得到tid值。

       - retval：指向返回值的指针。

     - 结束线程：pthread_exit(void *retval);

       子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。

       - retval：同上。

     - 分离线程：int pthread_detach(pthread_t tid);

       主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。

       - tid：同上。

2. 线程属性值修改

   - 背景知识：

     线程属性对象类型为pthread_attr_t，结构体定义如下：

     ```C++
     typedef struct{
         int etachstate;    // 线程分离的状态
         int schedpolicy;    // 线程调度策略
         struct sched_param schedparam;    // 线程的调度参数
         int inheritsched;    // 线程的继承性
         int scope;    // 线程的作用域
         // 以下为线程栈的设置
         size_t guardsize;    // 线程栈末尾警戒缓冲大小
         int stackaddr_set;    // 线程的栈设置
         void *    stackaddr;    // 线程栈的位置
         size_t stacksize;    // 线程栈大小
     }pthread_arrt_t;
     ```

   - 相关接口：

     对上述结构体中各参数大多有：pthread_attr_get***()和pthread_attr_set***()系统调用函数来设置和获取。这里不一一罗列。

3. 线程同步

   - [详见同步互斥专题](#mutex)

**多进程**

每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样，子进程创建时拷贝父进程PCB中大部分内容，而PCB的内容实际上是各种数据、代码的地址或索引表地址，所以复制了PCB中这些指针实际就等于获取了全部父进程可访问数据。所以简单来说，创建新进程需要复制整个PCB，之后操作系统将PCB添加到进程核心堆栈底部，这样就可以被操作系统感知和调度了。

父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。

1. 进程创建与结束

   - 背景知识：

     进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -> 1号内核进程 -> 1号用户进程(init进程) -> getty进程 -> shell进程 -> 命令行执行进程。所以我们在命令行中通过 ./program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。

   - 相关接口：

     - 创建进程：pid_t fork(void);

       返回值：出错返回-1；父进程中返回pid > 0；子进程中pid == 0

     - 结束进程：void exit(int status);

       - status是退出状态，保存在全局变量中S?，通常0表示正常退出。

     - 获得PID：pid_t getpid(void);

       返回调用者pid。

     - 获得父进程PID：pid_t getppid(void);

       返回父进程pid。

   - 其他补充：

     - 正常退出方式：exit()、_exit()、return（在main中）。

       exit()和_exit()区别：exit()是对_exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。

       return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。

     - 异常退出方式：abort()、终止信号。

2. 僵尸进程、孤儿进程

   - 背景知识：

     父进程在调用fork接口之后和子进程已经可以独立开，之后父进程和子进程就以未知的顺序向下执行（异步过程）。所以父进程和子进程都有可能先执行完。当父进程先结束，子进程此时就会变成孤儿进程，不过这种情况问题不大，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素。如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程。

   - 相关接口：

     - 回收进程（1）：pid_t wait(int *status);

       一旦调用wait()，就会立即阻塞自己，wait()自动分析某个子进程是否已经退出，如果找到僵尸进程就会负责收集和销毁，如果没有找到就一直阻塞在这里。

       - status：指向子进程结束状态值。

      - 回收进程（2）：pid_t waitpid(pid_t pid, int *status, int options);

        返回值：返回pid：返回收集的子进程id。返回-1：出错。返回0：没有被手机的子进程。

        - pid：子进程识别码，控制等待哪些子进程。
          1. pid < -1，等待进程组识别码为pid绝对值的任何进程。

          2. pid = -1，等待任何子进程。

          3. pid = 0，等待进程组识别码与目前进程相同的任何子进程。

          4. pid > 0，等待任何子进程识别码为pid的子进程。

        - status：指向返回码的指针。

        - options：选项决定父进程调用waitpid后的状态。

          1. options = WNOHANG，即使没有子进程退出也会立即返回。

          2. options = WUNYRACED，子进程进入暂停马上返回，但结束状态不予理会。

3. 守护进程

 - 背景知识：

   守护进程是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上并且也不会被终端发出的信号打断。

 - 操作步骤：

   - 创建子进程，父进程退出：fork() + if(pid > 0){exit(0);}，使子进程称为孤儿进程被init进程收养。

   - 在子进程中创建新会话：setsid()。

   - 改变当前目录结构为根：chdir("/")。

   - 重设文件掩码：umask(0)。

   - 关闭文件描述符：for(int i = 0; i < 65535; ++i){close(i);}。

4. Linux进程控制

- 进程地址空间（地址空间）

  虚拟存储器为每个进程提供了独占系统地址空间的假象。尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。有一些"敏感"的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。

- 进程控制块（处理机）

  进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。

- 上下文切换

  内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。

**线程、进程比较**

关于进程和线程的区别这里就不一一罗列了，主要对比下线程和进程操作中主要的接口。

- fork()和pthread_create()

  负责创建。调用fork()后返回两次，一次标识主进程一次标识子进程；调用pthread_create()后得到一个可以独立执行的线程。

- wait()和pthread_join()

  负责回收。调用wait()后父进程阻塞；调用pthread_join()后主线程阻塞。

- exit()和pthread_exit()

  负责退出。调用exit()后调用进程退出，控制权交给系统；调用pthread_exit()后线程退出，控制权交给主线程。

---

### <span id = "con">进程间通信</span>

Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。

**管道**

- 无名管道

  - 无名管道特点：

    - 无名管道是一种特殊的文件，这种文件只存在于内存中。

    - 无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。

    - 无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。

  - 相关接口：

    - int pipe(int fd[2]);

      - fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。

- 有名管道：

  - 有名管道特点：

    - 有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。

    - 无名管道可以在不具有亲缘关系的进程间进行通信。

  - 相关接口：

    - int mkfifo(const char *pathname, mode_t mode);

      - pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。

      - mode：和open()中的参数相同。


**消息队列**

**共享内存**

进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。

- 相关接口

  - 创建共享内存：int shmget(key_t key, int size, int flag);

    成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。

    - key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。

    - size：



**对Linux的了解至少要达到读过apue、unp这样子。特别是在实现这块，例如内存管理、文件系统这些都是常考的。在语言方面主要以C++为主，但并不涉及很深入的C++知识，一般四大名著过一遍就行了。**





 

操作系统

***\*进程间通信方式\****

管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

命名管道 (FIFO) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

信号量：信号量用于实现进程间的互斥与同步，也可以用在线程上，主要有posix信号量和System V信号量，posix信号量一般用在线程上，System V信号量一般用在进程上，posix信号量的函数一般都在下划线。

消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。(优先级，大小)

共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，常见的信号。

套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

***\*常见信号有哪些？\****：SIGINT，SIGKILL(不能被捕获)，SIGSTOP(不能被捕获)、SIGTERM(可以被捕获)，SIGSEGV，SIGCHLD，SIGALRM





标准io和文件io的区别

1.定义

　　标准ＩＯ：具有一定的可移植性。标准IO库处理很多细节。例如缓存分配，以优化长度执行IO等。标准的IO提供了三种类型的缓存。

（1）全缓存：当填满标准IO缓存后才进行实际的IO操作。

（2）行缓存：当输入或输出中遇到新行符时，标准IO库执行IO操作。

（3）不带缓存：stderr就是了。

　　文件ＩＯ：文件ＩＯ称之为不带缓存的IO（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于Unix平台。

2.区别

　　首先：两者一个显著的不同点在于，标准I/O默认采用了缓冲机制，比如调用fopen函数，不仅打开一个文件，而且建立了一个缓冲区（读写模式下将建立两个缓冲区），还创建了一个包含文件和缓冲区相关数据的数据结构(FILE *)。低级I/O一般没有采用缓冲，需要自己创建缓冲区，不过其实在linux系统中，都是有使用称为内核缓冲的技术用于提高效率，读写调用是在内核缓冲区和进程缓冲区之间进行的数据复制。使用标准IO就不需要自己维护缓冲区了，标准IO库会根据stdin/stdout来选择缓冲类型，也就是说当你使用标准IO的时候，要清楚它的stdin/stdou是什么类型以及其默认的缓冲模式，如果不合适，你需要用setvbuf先设置，再使用，例如协同进程的标准输入和输出的类型都是管道，所以其默认的缓冲类型是全缓冲的，如果要使用标准IO，就需要现设置行缓冲。对于文件IO，只要你自己能维护好缓冲区，完全可以不用标准IO。

　　其次从名字上来区分，文件I/O主要针对文件操作，读写硬盘等，标准I/O，主要是打印输出到屏幕等。因为他们设备不一样，文件io针对的是文件，标准io是对控制台，操作的是字符流。对于不同设备得特性不一样，必须有不同api访问才最高效。

 

wait和waitpid区别

　wait会令调用者阻塞直至某个子进程终止；

　　waitpid则可以通过设置一个选项来设置为非阻塞，另外waitpid并不是等待第一个结束的进程而是等待参数中pid指定的进程。

   ***\*waitpid中pid的含义依据其具体值而变\****：

　　pid==-1 等待任何一个子进程，此时waitpid的作用与wait相同

　　pid >0  等待进程ID与pid值相同的子进程

　　pid==0  等待与调用者进程组ID相同的任意子进程

　　pid<-1  等待进程组ID与pid绝对值相等的任意子进程

   ***\*waitpid提供了wait所没有的三个特性\****：

　　1 waitpid使我们可以等待指定的进程

　　2 waitpid提供了一个无阻塞的wait

　　3 waitpid支持工作控制

 

父进程fork后父子进程共享的内容

fork之后，子进程会拷贝父进程的数据空间、堆和栈空间（实际上是采用写时复制技术），二者共享代码段。 所以在子进程中修改全局变量（局部变量，分配在堆上的内存同样也是）后，父进程的相同的全局变量不会改变。

共享fd，以及fd对应的文件表项。

不同进程打开同一个文件

![img](file:///C:\Users\12037\AppData\Local\Temp\ksohtml2560\wps21.png) 

进程的fork与文件描述符的拷贝 进程的所打开文件和在fork后的结构图如下所示，子进程是共享父进程的文件表项。

![img](file:///C:\Users\12037\AppData\Local\Temp\ksohtml2560\wps22.png) 

ELF文件的理解

***\*section 是被链接器使用的，但是 segments 是被加载器所使用的。加载器会将所需要的 segment 加载到内存空间中运行。\****

1) 可重定位的对象文件(Relocatable file)(没有segments)

这是由汇编器汇编生成的 .o 文件。后面的链接器(link editor)拿一个或一些 Relocatable object files 作为输入，经链接处理后，生成一个可执行的对象文件 (Executable file) 或者一个可被共享的对象文件(Shared object file)。我们可以使用 ar 工具将众多的 .o Relocatable object files 归档(archive)成 .a 静态库文件。

2) 可执行的对象文件(Executable file)

3) 可被共享的对象文件(Shared object file)

这些就是所谓的动态库文件，也即 .so 文件。



在ELF文件里面，每一个 sections 内都装载了性质属性都一样的内容，比方：

1) .text section 里装载了可执行代码；

2) .data section 里面装载了被初始化的数据；

3) .bss section 里面装载了未被初始化的数据；

4) 以 .rec 打头的 sections 里面装载了重定位条目；

5) .symtab 或者 .dynsym section 里面装载了符号信息；

6) .strtab 或者 .dynstr section 里面装载了字符串信息；

7) 其他还有为满足不同目的所设置的section，比方满足调试的目的、满足动态链接与加载的目的等等。

 

把带有相同属性(比方都是只读并可加载的)的 section 都合并成所谓 segments(段)。最重要的是三个 segment：代码段，数据段和堆栈段。







 

linux程序启动过程

当你在 shell 中敲入一个命令要执行时，内核会帮我们创建一个新的进程，它在往这个新进程的进程空间里面加载进可执行程序的代码段和数据段后，也会加载进动态连接器(在Linux里面通常就是 /lib/ld-linux.so 符号链接所指向的那个程序，它本省就是一个动态库)的代码段和数据。在这之后，内核将控制传递给动态链接库里面的代码。动态连接器接下来负责加载该命令应用程序所需要使用的各种动态库。加载完毕，动态连接器才将控制传递给应用程序的main函数。如此，你的应用程序才得以运行。(过程链接表（PLT）,  Global Offset Table（GOT）)

 

 

产生死锁的四个必要条件：

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3）不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之

一不满足，就不会发生死锁。

 

处理死锁的基本方法：

****\*死锁预防\****：通过设置某些限制条件，去破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。

****\*死锁避免\****：允许前三个必要条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。

****\*死锁检测\****：不须实现采取任何限制性措施，而是允许系统在运行过程发生死锁，但可通过系统设置的检测机构及时检测出死锁的发生，并精确地确定于死锁相关的进程和资源，然后采取适当的措施，从系统中将已发生的死锁清除掉。

****\*死锁解除\****：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测盒解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。



vfork函数

vfork() 子进程与父进程共享数据段. vfork()保证子进程先运行，在她调用exec或_exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。



线程进程的区别体现在几个方面

1.因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。

2.体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。。

3.属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。

4.线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；

 

进程与线程的选择取决以下几点

1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。

2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应

3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；

4、并行操作时使用线程，如C/S[架构](http://lib.csdn.net/base/architecture)的服务器端并发线程响应用户的请求；

5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。

 

守护进程

守护进程是运行在后台的一种特殊进程, 不受终端控制，Linux系统的大多数服务器就是通过守护进程实现的。一个守护进程的父进程是init进程。***\*
\****

1）创建子进程，父进程退出

2）在子进程中创建新会话

3）改变当前目录为根目

4）重设文件权限掩码

5) 关闭文件描述符





Linux开机流程

加载BIOS的硬件信息与进行自我测试，并依据设置取得第一个可启动设备；

读取并执行第一个启动设备内MBR（主引导分区）的Boot Loader（即是gurb等程序）；

依据Boot Loader的设置加载Kernel，Kernel会开始检测硬件与加载驱动程序；

在硬件驱动成功后，Kernel会主动调用init进程（/sbin/init），而init会取得runlevel信息；

init执行/etc/rc.d/rc.sysinit文件来准备软件的操作环境（如网络、时区等）；

init执行runlevel的各个服务的启动（script方式）；

init执行/etc/rc.d/rc.local文件；

​     init执行终端机模拟程序mingetty来启动login程序，最后等待用户登录。