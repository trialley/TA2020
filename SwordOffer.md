1. 原书是C代码。
2. 建议首先学习全书一遍以上，再选择性地从网上寻找题解。
3. 本笔记展示书本中的要点以便于复习。
4. 本文编写风格尽量接近面试时给面试官讲题的情况。

注意方法的渐进优化

注意主动报错

注意代码健壮性

# 第一章 面试流程

1.赋值运算符函数
1. 问题重述：
2. 健壮性：
3. 一句话思路：
4. 方法一：xxx复杂度O(n)
5. 方法二：xxx复杂度O(1)

2.实现单例模式

# 第二章 面试所需的基础知识

3.数组中重复的数字

4.二维数组中的查找

5.替换空格

6.从尾到头打印链表

1. **问题重述：**将一个链表倒序打印出来
2. **健壮性：**输入的链表头指针是否为空？
3. **一句话思路：**第一反应是使用递归，但是递归有调用栈溢出风险，所以改用栈数据结构保存节点数据，再不断弹栈打印。上述两种方法都要开辟新空间，如果不想开辟新空间，可以原地将链表反转再打印
4. **方法一：**递归调用打印 O(n) 使用调用栈
5. **方法二：**循环入栈再出栈 O(n) 使用栈数据结构
6. **方法三：**反转链表再打印 O(n) 不开辟新空间

7.重建二叉树

1. **问题重述：**由前序（后序）与中序遍历序列中推断树本来的结构
2. **健壮性：**输入的两种序列数组头指针是否为空？输入的数组长度是否小于1？
3. **一句话思路：**本题目为数据结构课程的小重点。从前序（后序）遍历中获得根节点，从中序遍历获得根节点两个子树的序列。再递归重复此过程，直到子序列长度为0，返回空指针。
4. **方法一：**按照上述思路写出递归函数，注意健壮性，注意返回条件判断。每次递归调用都能确定一个节点，复杂度为O(n)

8.二叉树中序遍历的下一个结点

1. **问题重述：**所有节点除了左右子树指针，还有父节点指针。给出一个节点指针（不给出根节点指针），求树的中序遍历中下一个节点的指针。
2. **健壮性：**
   1. 输入的节点指针是否为空？
   2. 输入的节点是否是树的唯一节点？
   3. 输入的目标节点是否是中序序列的最后一个节点？(输入节点是当前树的最右节点)
3. **一句话思路：**此题应当画图分析。若该节点没有后序节点：可能该节点就是根节点，可能该节点是中序遍历最后一个节点。若有后序节点：输入节点有右子树，右子树的最左节点就是当前节点的后序节点。输入节点没有右子树，则其第一个向右父节点就是后继节点。（待补图）
4. **方法一：**按照上述思路编程，为了判断“向右父节点”应当时刻保存前一个遍历到的父节点。复杂度O(n)

9.1用两个栈实现队列

1. **问题重述：**如题
2. **健壮性：**无恶意输入
3. **一句话思路：**两个栈一个出栈一个入栈。入队时固定入到一个栈中，当要出队，将入栈全部弹到出栈中，一直出到出栈为空，再从入栈中全部弹到出栈中。
4. **方法一：**
5. **方法二：**

9.2用两个队列实现栈结构

10.1斐波那契数列

1. **问题重述：**获得第n个斐波那契数

2. **健壮性：**输入n为0。

3. **一句话思路：**该题方法多样，都是从时间复杂度下功夫。

4. **方法一：**首先是简单的递归调用。O(2^n)

   证明:(我也不会)
   $$
   设时间复杂度f(n)=f(n-1)+f(n-2) \quad n>1
   $$

   $$
   f(n)=\frac{1}{\sqrt{5}}
   $$

5. **方法二：**递归中有些部分需要重复计算，可以直接用，因此考虑动态规划法O(n)

6. **方法三**：求斐波那契数列有简化的公式O(logn)

10.2矩形覆盖

1. **问题重述：**2*1小矩形不重复不遗漏地覆盖一个大矩形，问都多少种覆盖方法？
2. 

10.3跳台阶

1. **问题重述：**一共n层台阶，每次只能向上跳一格或两格，问跳完台阶有多少种跳法。
2. **健壮性：**输入n为0。

10.4变态跳台阶

1. **问题重述：**一共n层台阶，每次能向上跳1…n个台阶，问多少种跳法。
3. 答：归纳证明有$2^{n-1}$种跳法。

11.旋转数组的最小数字

1. **问题重述：**有个n排好序的数组，分成两半，倒序拼接起来，求其中最小值。
2. **健壮性：**
   1. 数组指针为空
   2. 原数组分成了0+n两个数组
   3. 数组大量重复，致使新数组头尾相同，如$${\lbrace0,1,1,1,1\rbrace}\to{\lbrace1,1,| 0,1,1\rbrace}$$
   4. 
3. **思路：**
   1. 这个问题最简单的肯定是遍历，但那样复杂度是O(n)，但这不是最优解。
   2. 有序数组中找某项，二分法最好，时间复杂度是O(logn)，那怎么在劈叉的有序数组用二分？
   3. 二分中，若中间数大于数组首，则中间数属于左半部分，应当在右侧继续二分；若中间数小于数组尾，则中间数属于右半部分，应当在左侧继续二分。
4. **方法一：**穷举O(n)
5. **方法二：**二分O(logn)

12.矩阵中的路径

1. **问题重述：**输入一个字符矩阵和一个字符串，判断能否有一条不重复的线将字符串在字符矩阵中画出来。
2. **健壮性：**
   1. 输入的两个指针为空
   2. 矩阵只有一行或一列
3. **思路：**使用广度优先搜索回溯法，使用visited二位数组保存访问状态。
4. **方法一：**广度优先搜索回溯法

13.机器人的运动范围

1. **问题重述：**$m*n$列的数组，从（0,0）坐标开始上下左右移动，不能进入路径上数字按位相加之和大于k的格，问能够进入多少格子。
2. **健壮性：**
   1. 输入的数组为空
   2. 矩阵只有一行或一列
   3. 输入的k小于1
3. **思路：**和上一个题目一模一样，只不过是将字符比对变成数位和的检查。
4. **方法一：**广度优先搜索回溯法

14.剪绳子

1. **问题重述：**一段n长绳子减成两段或以上，将每段长度相乘，问剪成几段，每段多长能使乘积最大。
2. **健壮性：**
3. **思路：** 
   1. 分解子问题，第一剪有 1…n-1 种剪法，随后可以递归此过程。
   2. 递归产生冗余，自然就能用动态规划。优化后复杂度为O(n^2)
   3. 实际上还有种数学证明的贪婪算法。
4. **方法一：**递归O(n^3)？
5. **方法二：**动态规划O(n^2)
6. **方法三：**贪婪算法，需数学证明O(1)

15.二进制中1的个数

1. **问题重述：**求一个整数的二进制表示中1的个数。
2. **健壮性：**
   1. 数字正负问题。
3. **思路：** 
   1. 可以通过位移再跟1相与的办法判断每个位是否为1。
   2. 考虑到有符号移位可能产生错误，可以换成对掩码进行移位
   3. 使用数字技巧再次降低时间复杂度。数字与自身减一 `n=n&(n-1)` ，每计算一次使二进制中1的数量减一，直到该数为0，进行了多少次这样的运算数字的二进制就有多少个1。
4. **方法一：**位移与1计数O(n)注意有符号右移使1增多。
5. **方法二：**输入不移，掩码移。
6. **方法三：**循环跟自身减一进行与运算。
7. 扩展：
   1. 快速判断一个数字是不是2的整数次方，该数减一与自身为0.



# 第三章 高质量代码

16.数值的整数次方

1. **问题重述：**实现函数double Power(double base,int exponent)不考虑溢出。
2. **健壮性：**
   1. 底数是0时，不能用取倒数的方式计算负指数幂。
   2. 0的1次方是1。
3. **思路：** 
   1. 简单的是循环相乘，复杂度O(n)
   2. 考虑二分法，比如六次方是计算两个三次方O(logn)
   3. 再优化已经不能优化复杂度了，可以优化运算细节，比如指数除二改成右移一位。
4. **方法一：**仅展示最优代码。

17.打印从1到最大的n位数

1. **问题重述：**打印从1到最大的n位数，前导0不打印。
2. **健壮性：**
   1. 凡是数字都要考虑到0和极大这两个特殊情况。
   2. 打印数字时要去掉前导0.
3. **思路：** 
   1. 简单的是循环打印，但这样有溢出问题，是个陷阱。
   2. 模拟整数加法
      1. 因此考虑以开辟字符串的方式进行打印，每次循环给最低位加一，低位到了10就给高位进一。
      2. 我们需要判断数字是否增大到了n位，只需判断第n+1位是否为1即可。
   3. 模拟整数加法性能也很差，可以转化成数字排列问题。

18.1在O(1)时间内删除链表节点

1. **问题重述：**只给头指针和一个节点指针，从链表中删除这个节点，要求复杂度O(1)。
2. **健壮性：**
   1. 输入的是空指针
   2. 被删除节点是最后一个节点
   3. 链表只有被删除节点这一个节点
3. **思路：**
   1. 一般删除节点都是O(n)复杂度，因为需要从链表中找到被删除节点的前一个节点。
   2. 但题目要求我们必须O(1)，说明不能遍历搜索，必然是从被删除节点上下功夫。
   3. 可以将被删除节点的后继节点的值赋给被删除节点，将后继节点删除。

18.2删除链表中重复的结点

1. **问题重述：**给头指针指向一个排好序的节点，删除所有重复的节点。
2. **健壮性：**
   1. 输入的是空指针
   2. 头节点也可能被删除，则头指针的指向会改变，所以函数必须传入头指针的指针或头指针的引用。
   3. 若有多个相邻的重复节点，则这些重复节点都应删除，要考虑连续重复的情况。
3. **思路：**
   1. 没什么特殊思路，充分考虑到上述特殊情况即可。



**以下两个问题建议学会正则表达式再来看**

19.正则表达式匹配

1. **问题重述：**给定两个字符串，其中一个是正则表达式，判断字符串是否符合正则表达式。`'.'` 表示任意一个字符，`'X*'` 表示字符X可以连续出现任意次。
2. **健壮性：**
   1. 输入空指针
   2. `'*'` 前的字符出现0次
3. **思路：**
   1. 需要两个索引分别表示字符串和正则表达式的扫描位置。
   2. 注意正则表达式可以任意组合



20.表示数值的字符串

同上，也是一个正则表达式



21.调整数组顺序使奇数位于偶数前面

1. **问题重述：**一个数组，进行排序，要求所有奇数都在偶数后面
2. **健壮性：**
   1. 输入空指针
3. **思路：**
   1. 参考快速排序算法，两个索引从两侧向中间逼近。



22.链表中倒数第K个结点

1. **问题重述：**给出数字k和链表头指针，求该链表倒数第k个元素。
2. **健壮性：**
   1. 输入空指针
   2. k小于1
   3. k大于链表长度，输入一组数据和一个索引这种情况，常考虑索引是否越界。
3. **思路：**
   1. 最简单的遍历两次，第一次获得链表长度，第二次取倒数k个。
   2. 最好只遍历一次，我们可以取两个指针，一个指针走k步之后第二个指针才开始走，这样先走的指针走到头，第二个指针就指向倒数第k个。

23.链表中环的入口结点

1. **问题重述：**给出数字k和链表头指针，求该链表倒数第k个元素。
2. **健壮性：**
   1. 输入空指针
   2. k小于1
   3. k大于链表长度，输入一组数据和一个索引这种情况，常考虑索引是否越界。
3. **思路：**
   1. 最简单的遍历两次，第一次获得链表长度，第二次取倒数k个。
   2. 最好只遍历一次，我们可以取两个指针，一个指针走k步之后第二个指针才开始走，这样先走的指针走到头，第二个指针就指向倒数第k个。

24.反转链表

1. **问题重述：**不开新空间，在原地使链表反转。
2. **健壮性：**
   1. 输入空指针
   2. 链表只有一个节点
3. **思路：**
   1. 原地反转链表是重要知识点，可以逐个进行指针反转
   2. 有三个指针
      1. 一个指向当前反转节点
      2. 一个指向当前节点的的上一个节点，这个节点将变成后继节点。
      3. 一个指向当前节点的下一个节点，这个节点将是下一个当前节点，这个指针要进行判空。

25.合并两个排序的链表

1. **问题重述：**有序链表合并。
2. **健壮性：**
   1. 输入空指针
   2. 两链表长度不同
3. **思路：**
   1. 有序链表合并也是重要知识点
   2. 有两个指针分别指向两个链表
   3. 首先while循环对比两个指针指向数据的大小，其中一个加入到新链表中
   4. 如果其中一个指针先到了链表末尾（即空指针），则将剩下不为空的那个链表接到新链表后。

26.树的子结构

1. **问题重述：**给出两个树，判断树A是不是树B的子结构。
2. **健壮性：**
   1. 输入空指针
3. **思路：**
   1. 只需对B中每个节点都与A进行递归对比即可。
   2. 注意B的空指针不需要参加比对。

# 考虑到 解决面试题的思路



27.二叉树的镜像



28.对称的二叉树



29.顺时针打印矩阵



30.包含min函数的栈



31.栈的压入、弹出序列



32.1从上往下打印二叉树



32.2把二叉树打印成多行



32.3按之字形顺序打印二叉树



33.二叉搜索树的后序遍历序列



34.二叉树中和为某一值的路径



35.复杂链表的复制



36.二叉搜索树与双向链表



37.序列化二叉树



38.字符串的排列



# 第五章 优化时间和空间效率



39.数组中出现次数超过一半的数字



40.最小的K个数



41.1数据流中的中位数



41.2字符流中第一个不重复的字符



42.连续子数组的最大和



43.从1到n整数中1出现的次数



44.数字序列中的某一位数字



45.把数组排成最小的数



46.把数字翻译成字符串



47.礼物的最大价值



48.最长不含重复字符的子字符串



49.丑数



50.第一个只出现一次的字符位置



51.数组中的逆序对



52.两个链表的第一个公共结点



# 第六章 面试中的各项能力



53.数字在排序数组中出现的次数



54.二叉查找树的第K个结点



55.1二叉树的深度



55.2平衡二叉树



56.数组中只出现一次的数字



57.1和为S的两个数字



57.2和为S的连续正数序列



58.1翻转单词顺序列



58.2左旋转字符串



59.滑动窗口的最大值



60.n个骰子的点数



61.扑克牌顺子



62.圆圈中最后剩下的数



63.股票的最大利润



64.求1+2+3+...+n



65.不用加减乘除做加法



66.构建乘积数组



# 第七章 两个面试案例



67.把字符串转换成整数



68.树中两个节点的最低公共祖先