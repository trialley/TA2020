hhh



inndb

https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453141496&idx=2&sn=cd49b422f47cecf01657017cf0dbaa10&chksm=8cf2d57bbb855c6db05ed2dac05c6e22b2aeafbd95defc087fbbd0c9daa96566e1235f483310&mpshare=1&scene=23&srcid=&sharer_sharetime=1581342192782&sharer_shareid=b6b87345d536273dbb065f6dcfaba376#rd







# 数据库基础

## 讲一讲事务

1. 数据库事务(Database Transaction) ，是指作为**单个逻辑工作**单元执行的满足**ACID**原则的一系列操
2. 要么完全地**执行**，要么完全地**不执行**。
3. 将一组操作单元化，可以**简化错误恢复**并使应用程序更加可靠。
4. 一个逻辑工作单元要成为事务，必须满足所谓的**ACID**
   1. 原子性（atomicity）：一个事务必须被是一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚
   2. 一致性（consistency）：数据库总是从一个一致性的状态转移到另一个一致性的状态。比如这里减钱那里就必须加钱，状态均衡。
   3. 隔离性（isolation）：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
   4. 持久性（durability）：一旦事务提交，则其所作的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。

## 说说事务隔离

四大隔离级别，以及不可重复读和幻影读的出现原因。

数据库事务的隔离级别有4种，由低到高分别为

Read uncommitted

Read committed

Repeatable read

Serializable 

在事务的并发操作中可能会出现**脏读，不可重复读，幻读**，下面将渐进地讲述问题产生原因与解决方案。



1. 读未提交 Read uncommitted  改前读 导致脏读
   1. 顾名思义，就是一个事务可以**读取另一个未提交**事务的数据。
   2. 事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。
   3. 脏读：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。

那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。

2. 读提交 Read committed 改交后再读 导致不可重复读 **大多数**
   1. 顾名思义，就是一个事务要等另一个事务提交后才能读取数据。
   2. 事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…
   3. 分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内**两个相同的查询却返回了不同数据**，这就是不可重复读。

那怎么解决可能的不可重复读问题？ Repeatable read ！

3. 重复读 Repeatable read  读完再改可插 导致幻读  MySQL
   1. 就是在开始读取数据（事务开启）时，不再允许修改操作（可以插入）
   2. 事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（**事务开启，不允许其他事务的UPDATE修改操作**），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。
   3. 分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。



**什么时候会出现幻读？**

事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。

那怎么解决幻读问题？Serializable！

4. Serializable 序列化 事务不可重叠
   1. Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

> 大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。

## 说说索引

多加索引一定会好吗

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。

索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。

1、索引

数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。

DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。

优点：

通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

缺点：

创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

2、添加索引原则

在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。



## 说一说数据库范式

![20190414100321526](DataBase.assets/20190414100321526.jpg)



关系数据库有六种，一、二、三、四、五和BC。满足最低要求的范式是第一范式。在第一范式的基础上进一步满足更多要求的称为第二范式，其余范式以此类推。一般情况的数据库只需满足第三范式即可。

### 1NF

如果关系模式R是第一范式的模式，那么，R的每一个关系r的属性都是原子项，不可分割。

![img](https://img-blog.csdn.net/20151002111606668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不能称为关系型数据库。关系数据库设计研究的关系规范化是在1NF之上进行的。

### 2NF

1. 定义：符合1NF，并且，**非主属性不能只依赖主键的一部分**。

2. 反例：学生上课指定一个老师，一本教材，一个教室，一个时间，学生去上课，怎么设计数据库？![img](https://img-blog.csdn.net/20151002152345014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)（学生，课程）是一个码，课程却决定了教材，这就叫做不完全依赖，或者说部分依赖。 出现了这种情况，就不满足第二范式了。

3. 第一转第二范式：进行投影分解，将部分依赖的依赖者提取出来。

![img](https://img-blog.csdn.net/20151002153453910?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 3NF

定义：2NF，所有非主属性对任何候选关键字都不存在传递依赖（不能有被非主属性决定的非主属性）。

反例：上图中符合2NF ，但存在传递依赖（老师——>老师职称。一个老师一定能确定一个老师职称）。

解决：将传递依赖的拿出来

![img](https://img-blog.csdn.net/20151002154348213?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### BCNF

定义：主属性不依赖于主属性

还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。



## 第四范式



### 第五范式

尽力分割，原来的表格必须可以通过由它分离出去的表格重新构建 

# Redis

## redis单线程性能

虽然Redis文件事件处理器以单线程方式运行，但是通过使用I/O多路复用Reactor程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程运行的模块进行对接，这保持了Redis内部单线程设计的简单性。

## redis定时机制

Redis是一个事件驱动程序，服务器需要处理以下**两类**事件：文件事件（服务器对套接字操作的抽象）和时间事件（服务器对定时操作的抽象）。Redis的定时机制就是借助时间事件实现的。

一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件



## mongdb和redis的区别

内存管理机制上：Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。

支持的数据结构上：Redis 支持的数据结构丰富，包括hash、set、list等。

MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富

## 数据类型

| 数据类型 |      可以存储的值      |                             操作                             |
| :------: | :--------------------: | :----------------------------------------------------------: |
|  STRING  | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作对整数和浮点数执行自增或者自减操作 |
|   LIST   |          列表          | 从两端压入或者弹出元素<br />对单个或者多个元素进行修剪<br />只保留一个范围内的元素 |
|   SET    |        无序集合        | 添加、获取、移除单个元素<br /> 检查一个元素是否存在于集合中<br />计算交集、并集、差集<br />从集合里面随机获取元素 |
|   HASH   | 包含键值对的无序散列表 | 添加、获取、移除单个键值对<br /> 获取所有键值对<br /> 检查某个键是否存在 |
|   ZSET   |        有序集合        | 添加、获取、删除元素<br />根据分值范围或者成员来获取元素<br />计算一个键的排名 |



### STRING

redis中的Key和Value时区分大小写的，命令不区分大小写， redis是单线程 不适合存储大容量的数据

```html
> set hello world
OK
> get hello
"world"
> del hello
(integer) 1
> get hello
(nil)
```

### LIST

```html
> rpush list-key item
(integer) 1
> rpush list-key item2
(integer) 2
> rpush list-key item
(integer) 3

> lrange list-key 0 -1
1) "item"
2) "item2"
3) "item"

> lindex list-key 1
"item2"

> lpop list-key
"item"

> lrange list-key 0 -1
1) "item2"
2) "item"
```

### SET

```html
> sadd set-key item
(integer) 1
> sadd set-key item2
(integer) 1
> sadd set-key item3
(integer) 1
> sadd set-key item
(integer) 0

> smembers set-key
1) "item"
2) "item2"
3) "item3"

> sismember set-key item4
(integer) 0
> sismember set-key item
(integer) 1

> srem set-key item2
(integer) 1
> srem set-key item2
(integer) 0

> smembers set-key
1) "item"
2) "item3"
```

### HASH

Redis中的散列可以看成具有String key和String value的map容器

hget hset hgetall hdel

```html
> hset hash-key sub-key1 value1
(integer) 1
> hset hash-key sub-key2 value2
(integer) 1
> hset hash-key sub-key1 value1
(integer) 0

> hgetall hash-key
1) "sub-key1"
2) "value1"
3) "sub-key2"
4) "value2"

> hdel hash-key sub-key2
(integer) 1
> hdel hash-key sub-key2
(integer) 0

> hget hash-key sub-key1
"value1"

> hgetall hash-key
1) "sub-key1"
2) "value1"
```

### ZSET

```html
> zadd zset-key 728 member1
(integer) 1
> zadd zset-key 982 member0
(integer) 1
> zadd zset-key 982 member0
(integer) 0

> zrange zset-key 0 -1 withscores
1) "member1"
2) "728"
3) "member0"
4) "982"

> zrangebyscore zset-key 0 800 withscores
1) "member1"
2) "728"

> zrem zset-key member1
(integer) 1
> zrem zset-key member1
(integer) 0

> zrange zset-key 0 -1 withscores
1) "member0"
2) "982"
```



## 数据结构

## 场景

## 键过期

## 数据淘汰

## 持久化 RDB和AOF

redis有两种持久化方式：RDB（Redis DataBase）和AOF（Apend Only File）。具体差别跟优缺点可参考[redis数据的两种持久化方式对比](https://www.jb51.net/article/121848.htm)，本篇只介绍这两种方式怎么配置

### RDB

默认情况下，是快照RDB的持久化方式，将内存中的数据以快照的方式写入二进制文件中，默认的文件名是dump.rdb

![img](DataBase.assets/577787f6e8024459975a04357e7385f9.png)

redis.conf默认配置：

```
save 900 1
save 300 10
save 60 10000
```



 配置含义：

 900秒内，如果超过1个key被修改，则发起快照保存

 300秒内，如果超过10个key被修改，则发起快照保存

 60秒内，如果1万个key被修改，则发起快照保存

 默认配置不方便看效果，可将快照频率设大一点，在redis.conf中增加一行：

save 10 1

保存后，启动redis服务端和客户端。在客户端输入命令：

![img](DataBase.assets/06f92cfe63004fdbb44a7c481616d390.png)

输入完，发现dump.rdb文件的修改日期变了，并且redis服务端增加了保存日志：

![img](DataBase.assets/920383c208894bbea95c932215932040.png)

接下来，重启redis服务端和客户端，看数据是否真的持久化了：

![img](DataBase.assets/eb5f060823074b0aab87a1a42a25fa06.png)

妥妥的~，说明使用RDB快照持久化成功了

### AOF 配置方式

存储命令行

redis.conf默认配置：

```
appendonly no
```

配置文件中的appendonly修改为yes，开启AOF持久化。开启后，启动redis服务端，发现多了一个appendonly.aof文件

![img](DataBase.assets/33acf76b16ff4643a12c879265dbdf5c.png)

使用AOF做持久化，每一个命令以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写，使得 AOF文件的体积不会超出保存数据集状态所需的实际大小。实际上，AOF持久化并不会立即将命令写入到硬盘文件中，而是写入到硬盘缓存，在接下来的策略中，配置多久来从硬盘缓存写入到硬盘文件。所以在一定程度一定条件下，还是会有数据丢失，不过你可以大大减少数据损失

```
# appendfsync always
appendfsync everysec
# appendfsync no
```



配置含义：

always: 每次操作都会立即写入aof文件中

everysec: 每秒持久化一次(默认配置)

no: 不主动进行同步操作，默认30s一次

当然**always**一定是效率最低的，个人认为**everysec**就够用了，数据安全性能又高。Redis也允许我们同时使用两种方式，再重启redis后会从AOF中恢复数据，因为AOF比RDB数据损失小嘛

配置好后，启动redis客户端，输入命令：

![img](DataBase.assets/67f03b48fc394374a207a811ef252ce9.png)

最后的flushall是清除所有的键值。打开appendonly.aof文件，可以看到：

![img](DataBase.assets/77380d0408254ec49721aebe93e7511c.png)

去掉最后面的flushall(也可以按照redis协议增加命令)，重启客户端和服务端，看数据是否真的持久化了：

![img](DataBase.assets/08cdaac1e42a45539d480b484bdc34a0.png)

妥妥的~，说明使用AOF持久化也成功了



## 事务



一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。



事务的错误处理

1. 提交前命令输错，则前面的命令全部丢失
2. 

## 事件



## 复制



## Sentinel





## 分片



## 简单论坛系统分析





# MySQL



## 1 索引

### 索引实现

#### B树

B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。是大多数MySQL的默认引擎，

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为 null，则该指针指向节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>。

1. 查找：进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。
2. 插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

使用B树而不是红黑树的原因：

1. 内存与磁盘以页为单位交换数据。将索引的一个节点的大小设置为页的大小，一次 I/O 能完全载入一个节点。还可以利用预读特性，相邻的节点也能够被预先载入。

#### 哈希

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。



#### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

#### 空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。



### 索引优化

1. 独立的列

   在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

   例如下面的查询不能使用 actor_id 列的索引：

   ```sql
   SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
   ```

2. 使用多列索引

   在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

   ```sql
   SELECT film_id, actor_ id FROM sakila.film_actor
   WHERE actor_id = 1 AND film_id = 1;
   ```

3. 合理安排索引列的顺序

   让选择性最强的索引列放在前面。

   索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

   例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

   ```sql
   SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
   COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
   COUNT(*)
   FROM payment;
   ```

   ```html
      staff_id_selectivity: 0.0001
   customer_id_selectivity: 0.0373
                  COUNT(*): 16049
   ```

4. 前缀索引

   对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

   前缀长度的选取需要根据索引选择性来确定。

5. 覆盖索引

   索引包含所有需要查询的字段的值。

   具有以下优点：

   - 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
   - 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
   - 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。





### 索引的优点

- 减少了服务器需要扫描的数据行数。
- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。**临时表主要是在排序和分组过程中创建**，不需要排序和分组，也就不需要创建临时表）。
- 将随机 I/O 变为顺序 I/O（**B+Tree 索引是有序的**，会将相邻的数据都存储在一起）。



### 索引性能差的情况

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。



## 2 性能优化



## 3 存储引擎

在Mysql数据库中，常用的引擎为Innodb和MyIASM,其中Innodb是一个事务型的存储引擎，有行级锁定和外键约束，提供了对数据库ACID事物的支持，实现了SQL标准的四种隔离级别，即读未提交，不可重复读，可重复读以及串行,其涉及目标就是处理大数据容量的数据库系统。而MyIASM引擎是Mysql默认的引擎，不提供数据库事务的支持，也不支持行级锁和外键，因此当写操作时需要锁定整个表，效率较低。不过其保存了表的行数，当金星select count(*)form table时，可直接读取已经保存的值，不需要进行全表扫描。因此当表的读操作远多于写操作，并且不需要事务支持时，可以优先选择MyIASM

### InnoDB

是 **MySQL 默认**的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。

主索引是**聚簇索引**，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

### 比较

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。

- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。

- 外键：InnoDB 支持外键。

- 备份：InnoDB 支持在线热备份。archivelog mode

- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。

- 其它特性：MyISAM 支持压缩表和空间数据索引。

## 4 数据类型

1. 整型

   1. TINYINT 8
   2.  SMALLINT16
   3. MEDIUMINT24
   4. INT32
   5. BIGINT64

   > INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

2. 浮点数

   1. FLOAT 和 DOUBLE
   2. DECIMAL 为高精度小数类型 计算慢

   FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽?，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

3. 字符串

   1. CHAR 定长
   2. VARCHAR 变长 节省空间 执行 UPDATE 时可能会使行变得比原来长

   VARCHAR 这种变长类型能够，因为只需要存储必要的内容。但是在，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

   在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。

4. 时间和日期

   1. DATETIME能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。
      1. 它与时区无关。
      2. 默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22<span>:</span>37<span>:</span>08”，这是 ANSI 标准定义的日期和时间表示方法。

   2. TIMESTAMP
      1. 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。
      2. 它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。
      3. MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。
      4. 默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。
   3. 应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。

## 5 切分

>

## 6 复制





